/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.0
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGJAVA
#define SWIG_DIRECTORS


#ifdef __cplusplus
/* SwigValueWrapper is described in swig.swg */
template<typename T> class SwigValueWrapper {
  struct SwigMovePointer {
    T *ptr;
    SwigMovePointer(T *p) : ptr(p) { }
    ~SwigMovePointer() { delete ptr; }
    SwigMovePointer& operator=(SwigMovePointer& rhs) { T* oldptr = ptr; ptr = 0; delete oldptr; ptr = rhs.ptr; rhs.ptr = 0; return *this; }
  } pointer;
  SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
  SwigValueWrapper(const SwigValueWrapper<T>& rhs);
public:
  SwigValueWrapper() : pointer(0) { }
  SwigValueWrapper& operator=(const T& t) { SwigMovePointer tmp(new T(t)); pointer = tmp; return *this; }
  operator T&() const { return *pointer.ptr; }
  T *operator&() { return pointer.ptr; }
};

template <typename T> T SwigValueInit() {
  return T();
}
#endif

/* -----------------------------------------------------------------------------
 *  This section contains generic SWIG labels for method/variable
 *  declarations/attributes, and other compiler dependent labels.
 * ----------------------------------------------------------------------------- */

/* template workaround for compilers that cannot correctly implement the C++ standard */
#ifndef SWIGTEMPLATEDISAMBIGUATOR
# if defined(__SUNPRO_CC) && (__SUNPRO_CC <= 0x560)
#  define SWIGTEMPLATEDISAMBIGUATOR template
# elif defined(__HP_aCC)
/* Needed even with `aCC -AA' when `aCC -V' reports HP ANSI C++ B3910B A.03.55 */
/* If we find a maximum version that requires this, the test would be __HP_aCC <= 35500 for A.03.55 */
#  define SWIGTEMPLATEDISAMBIGUATOR template
# else
#  define SWIGTEMPLATEDISAMBIGUATOR
# endif
#endif

/* inline attribute */
#ifndef SWIGINLINE
# if defined(__cplusplus) || (defined(__GNUC__) && !defined(__STRICT_ANSI__))
#   define SWIGINLINE inline
# else
#   define SWIGINLINE
# endif
#endif

/* attribute recognised by some compilers to avoid 'unused' warnings */
#ifndef SWIGUNUSED
# if defined(__GNUC__)
#   if !(defined(__cplusplus)) || (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#     define SWIGUNUSED __attribute__ ((__unused__)) 
#   else
#     define SWIGUNUSED
#   endif
# elif defined(__ICC)
#   define SWIGUNUSED __attribute__ ((__unused__)) 
# else
#   define SWIGUNUSED 
# endif
#endif

#ifndef SWIG_MSC_UNSUPPRESS_4505
# if defined(_MSC_VER)
#   pragma warning(disable : 4505) /* unreferenced local function has been removed */
# endif 
#endif

#ifndef SWIGUNUSEDPARM
# ifdef __cplusplus
#   define SWIGUNUSEDPARM(p)
# else
#   define SWIGUNUSEDPARM(p) p SWIGUNUSED 
# endif
#endif

/* internal SWIG method */
#ifndef SWIGINTERN
# define SWIGINTERN static SWIGUNUSED
#endif

/* internal inline SWIG method */
#ifndef SWIGINTERNINLINE
# define SWIGINTERNINLINE SWIGINTERN SWIGINLINE
#endif

/* exporting methods */
#if (__GNUC__ >= 4) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#  ifndef GCC_HASCLASSVISIBILITY
#    define GCC_HASCLASSVISIBILITY
#  endif
#endif

#ifndef SWIGEXPORT
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   if defined(STATIC_LINKED)
#     define SWIGEXPORT
#   else
#     define SWIGEXPORT __declspec(dllexport)
#   endif
# else
#   if defined(__GNUC__) && defined(GCC_HASCLASSVISIBILITY)
#     define SWIGEXPORT __attribute__ ((visibility("default")))
#   else
#     define SWIGEXPORT
#   endif
# endif
#endif

/* calling conventions for Windows */
#ifndef SWIGSTDCALL
# if defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__)
#   define SWIGSTDCALL __stdcall
# else
#   define SWIGSTDCALL
# endif 
#endif

/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
#if !defined(SWIG_NO_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_CRT_SECURE_NO_DEPRECATE)
# define _CRT_SECURE_NO_DEPRECATE
#endif

/* Deal with Microsoft's attempt at deprecating methods in the standard C++ library */
#if !defined(SWIG_NO_SCL_SECURE_NO_DEPRECATE) && defined(_MSC_VER) && !defined(_SCL_SECURE_NO_DEPRECATE)
# define _SCL_SECURE_NO_DEPRECATE
#endif



/* Fix for jlong on some versions of gcc on Windows */
#if defined(__GNUC__) && !defined(__INTEL_COMPILER)
  typedef long long __int64;
#endif

/* Fix for jlong on 64-bit x86 Solaris */
#if defined(__x86_64)
# ifdef _LP64
#   undef _LP64
# endif
#endif

#include <jni.h>
#include <stdlib.h>
#include <string.h>


/* Support for throwing Java exceptions */
typedef enum {
  SWIG_JavaOutOfMemoryError = 1, 
  SWIG_JavaIOException, 
  SWIG_JavaRuntimeException, 
  SWIG_JavaIndexOutOfBoundsException,
  SWIG_JavaArithmeticException,
  SWIG_JavaIllegalArgumentException,
  SWIG_JavaNullPointerException,
  SWIG_JavaDirectorPureVirtual,
  SWIG_JavaUnknownError
} SWIG_JavaExceptionCodes;

typedef struct {
  SWIG_JavaExceptionCodes code;
  const char *java_exception;
} SWIG_JavaExceptions_t;


static void SWIGUNUSED SWIG_JavaThrowException(JNIEnv *jenv, SWIG_JavaExceptionCodes code, const char *msg) {
  jclass excep;
  static const SWIG_JavaExceptions_t java_exceptions[] = {
    { SWIG_JavaOutOfMemoryError, "java/lang/OutOfMemoryError" },
    { SWIG_JavaIOException, "java/io/IOException" },
    { SWIG_JavaRuntimeException, "java/lang/RuntimeException" },
    { SWIG_JavaIndexOutOfBoundsException, "java/lang/IndexOutOfBoundsException" },
    { SWIG_JavaArithmeticException, "java/lang/ArithmeticException" },
    { SWIG_JavaIllegalArgumentException, "java/lang/IllegalArgumentException" },
    { SWIG_JavaNullPointerException, "java/lang/NullPointerException" },
    { SWIG_JavaDirectorPureVirtual, "java/lang/RuntimeException" },
    { SWIG_JavaUnknownError,  "java/lang/UnknownError" },
    { (SWIG_JavaExceptionCodes)0,  "java/lang/UnknownError" }
  };
  const SWIG_JavaExceptions_t *except_ptr = java_exceptions;

  while (except_ptr->code != code && except_ptr->code)
    except_ptr++;

  jenv->ExceptionClear();
  excep = jenv->FindClass(except_ptr->java_exception);
  if (excep)
    jenv->ThrowNew(excep, msg);
}


/* Contract support */

#define SWIG_contract_assert(nullreturn, expr, msg) if (!(expr)) {SWIG_JavaThrowException(jenv, SWIG_JavaIllegalArgumentException, msg); return nullreturn; } else

/*  Errors in SWIG */
#define  SWIG_UnknownError    	   -1 
#define  SWIG_IOError        	   -2 
#define  SWIG_RuntimeError   	   -3 
#define  SWIG_IndexError     	   -4 
#define  SWIG_TypeError      	   -5 
#define  SWIG_DivisionByZero 	   -6 
#define  SWIG_OverflowError  	   -7 
#define  SWIG_SyntaxError    	   -8 
#define  SWIG_ValueError     	   -9 
#define  SWIG_SystemError    	   -10
#define  SWIG_AttributeError 	   -11
#define  SWIG_MemoryError    	   -12 
#define  SWIG_NullReferenceError   -13



/* -----------------------------------------------------------------------------
 * director.swg
 *
 * This file contains support for director classes that proxy
 * method calls from C++ to Java extensions.
 * ----------------------------------------------------------------------------- */

#ifdef __cplusplus

#if defined(DEBUG_DIRECTOR_OWNED)
#include <iostream>
#endif

namespace Swig {
  /* Java object wrapper */
  class JObjectWrapper {
  public:
    JObjectWrapper() : jthis_(NULL), weak_global_(true) {
    }

    ~JObjectWrapper() {
      jthis_ = NULL;
      weak_global_ = true;
    }

    bool set(JNIEnv *jenv, jobject jobj, bool mem_own, bool weak_global) {
      if (!jthis_) {
        weak_global_ = weak_global;
        if (jobj)
          jthis_ = ((weak_global_ || !mem_own) ? jenv->NewWeakGlobalRef(jobj) : jenv->NewGlobalRef(jobj));
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> " << jthis_ << std::endl;
#endif
        return true;
      } else {
#if defined(DEBUG_DIRECTOR_OWNED)
        std::cout << "JObjectWrapper::set(" << jobj << ", " << (weak_global ? "weak_global" : "global_ref") << ") -> already set" << std::endl;
#endif
        return false;
      }
    }

    jobject get(JNIEnv *jenv) const {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::get(";
      if (jthis_)
        std::cout << jthis_;
      else
        std::cout << "null";
      std::cout << ") -> return new local ref" << std::endl;
#endif
      return (jthis_ ? jenv->NewLocalRef(jthis_) : jthis_);
    }

    void release(JNIEnv *jenv) {
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "JObjectWrapper::release(" << jthis_ << "): " << (weak_global_ ? "weak global ref" : "global ref") << std::endl;
#endif
      if (jthis_) {
        if (weak_global_) {
          if (jenv->IsSameObject(jthis_, NULL) == JNI_FALSE)
            jenv->DeleteWeakGlobalRef((jweak)jthis_);
        } else
          jenv->DeleteGlobalRef(jthis_);
      }

      jthis_ = NULL;
      weak_global_ = true;
    }

    jobject peek() {
      return jthis_;
    }

    /* Java proxy releases ownership of C++ object, C++ object is now
       responsible for destruction (creates NewGlobalRef to pin Java
       proxy) */
    void java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      if (take_or_release) {  /* Java takes ownership of C++ object's lifetime. */
        if (!weak_global_) {
          jenv->DeleteGlobalRef(jthis_);
          jthis_ = jenv->NewWeakGlobalRef(jself);
          weak_global_ = true;
        }
      } else { /* Java releases ownership of C++ object's lifetime */
        if (weak_global_) {
          jenv->DeleteWeakGlobalRef((jweak)jthis_);
          jthis_ = jenv->NewGlobalRef(jself);
          weak_global_ = false;
        }
      }
    }

  private:
    /* pointer to Java object */
    jobject jthis_;
    /* Local or global reference flag */
    bool weak_global_;
  };

  /* director base class */
  class Director {
    /* pointer to Java virtual machine */
    JavaVM *swig_jvm_;

  protected:
#if defined (_MSC_VER) && (_MSC_VER<1300)
    class JNIEnvWrapper;
    friend class JNIEnvWrapper;
#endif
    /* Utility class for managing the JNI environment */
    class JNIEnvWrapper {
      const Director *director_;
      JNIEnv *jenv_;
    public:
      JNIEnvWrapper(const Director *director) : director_(director), jenv_(0) {
#if defined(SWIG_JAVA_ATTACH_CURRENT_THREAD_AS_DAEMON)
        // Attach a daemon thread to the JVM. Useful when the JVM should not wait for 
        // the thread to exit upon shutdown. Only for jdk-1.4 and later.
        director_->swig_jvm_->AttachCurrentThreadAsDaemon((void **) &jenv_, NULL);
#else
        director_->swig_jvm_->AttachCurrentThread((void **) &jenv_, NULL);
#endif
      }
      ~JNIEnvWrapper() {
#if !defined(SWIG_JAVA_NO_DETACH_CURRENT_THREAD)
        // Some JVMs, eg jdk-1.4.2 and lower on Solaris have a bug and crash with the DetachCurrentThread call.
        // However, without this call, the JVM hangs on exit when the thread was not created by the JVM and creates a memory leak.
        director_->swig_jvm_->DetachCurrentThread();
#endif
      }
      JNIEnv *getJNIEnv() const {
        return jenv_;
      }
    };

    /* Java object wrapper */
    JObjectWrapper swig_self_;

    /* Disconnect director from Java object */
    void swig_disconnect_director_self(const char *disconn_method) {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      jobject jobj = swig_self_.peek();
#if defined(DEBUG_DIRECTOR_OWNED)
      std::cout << "Swig::Director::disconnect_director_self(" << jobj << ")" << std::endl;
#endif
      if (jobj && jenv->IsSameObject(jobj, NULL) == JNI_FALSE) {
        jmethodID disconn_meth = jenv->GetMethodID(jenv->GetObjectClass(jobj), disconn_method, "()V");
        if (disconn_meth) {
#if defined(DEBUG_DIRECTOR_OWNED)
          std::cout << "Swig::Director::disconnect_director_self upcall to " << disconn_method << std::endl;
#endif
          jenv->CallVoidMethod(jobj, disconn_meth);
        }
      }
    }

  public:
    Director(JNIEnv *jenv) : swig_jvm_((JavaVM *) NULL), swig_self_() {
      /* Acquire the Java VM pointer */
      jenv->GetJavaVM(&swig_jvm_);
    }

    virtual ~Director() {
      JNIEnvWrapper jnienv(this) ;
      JNIEnv *jenv = jnienv.getJNIEnv() ;
      swig_self_.release(jenv);
    }

    bool swig_set_self(JNIEnv *jenv, jobject jself, bool mem_own, bool weak_global) {
      return swig_self_.set(jenv, jself, mem_own, weak_global);
    }

    jobject swig_get_self(JNIEnv *jenv) const {
      return swig_self_.get(jenv);
    }

    // Change C++ object's ownership, relative to Java
    void swig_java_change_ownership(JNIEnv *jenv, jobject jself, bool take_or_release) {
      swig_self_.java_change_ownership(jenv, jself, take_or_release);
    }
  };
}

#endif /* __cplusplus */


namespace Swig {
  static jclass jclass_indriJNI = NULL;
  static jmethodID director_methids[1];
}

#include "indri/indri-platform.h"
#ifdef INDRI_STANDALONE
#include "lemur/lemur-compat.hpp"
#else
#include "lemur-compat.hpp"
#endif
#include "indri/QueryEnvironment.hpp"
#include "indri/QueryExpander.hpp"
#include "indri/RMExpander.hpp"
#include "indri/PonteExpander.hpp"
#include "indri/ScoredExtentResult.hpp"
#include "indri/ParsedDocument.hpp"
#include "indri/IndexEnvironment.hpp"
#include "indri/Parameters.hpp"
#include "indri/ConflationPattern.hpp"
#include "indri/ReformulateQuery.hpp"

#ifdef INDRI_STANDALONE
#include "lemur/Exception.hpp"
#else
#include "Exception.hpp"
#endif
  

#include <string>


SWIGINTERN void SWIG_JavaException(JNIEnv *jenv, int code, const char *msg) {
  SWIG_JavaExceptionCodes exception_code = SWIG_JavaUnknownError;
  switch(code) {
  case SWIG_MemoryError:
    exception_code = SWIG_JavaOutOfMemoryError;
    break;
  case SWIG_IOError:
    exception_code = SWIG_JavaIOException;
    break;
  case SWIG_SystemError:
  case SWIG_RuntimeError:
    exception_code = SWIG_JavaRuntimeException;
    break;
  case SWIG_OverflowError:
  case SWIG_IndexError:
    exception_code = SWIG_JavaIndexOutOfBoundsException;
    break;
  case SWIG_DivisionByZero:
    exception_code = SWIG_JavaArithmeticException;
    break;
  case SWIG_SyntaxError:
  case SWIG_ValueError:
  case SWIG_TypeError:
    exception_code = SWIG_JavaIllegalArgumentException;
    break;
  case SWIG_UnknownError:
  default:
    exception_code = SWIG_JavaUnknownError;
    break;
  }
  SWIG_JavaThrowException(jenv, exception_code, msg);
}


#include <stdexcept>


  jobjectArray java_build_scoredextentresult( JNIEnv* jenv, const std::vector<indri::api::ScoredExtentResult>& input ) {
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jmethodID constructor = jenv->GetMethodID(clazz, "<init>", "()V" );
    jobjectArray result;

    result = jenv->NewObjectArray(input.size(), clazz, NULL);
    if (!result) {
      return 0;
    }

    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");

    for( jsize i=0; i<input.size(); i++ ) {
      // make a new scored extent result object
      jobject ser = jenv->NewObject(clazz, constructor);

      // fill in the fields
      jenv->SetDoubleField(ser, scoreField, input[i].score );
      jenv->SetIntField(ser, beginField, input[i].begin );
      jenv->SetIntField(ser, endField, input[i].end );
      jenv->SetIntField(ser, documentField, input[i].document );
      jenv->SetLongField(ser, numberField, input[i].number);
      jenv->SetIntField(ser, ordField, input[i].ordinal);
      jenv->SetIntField(ser, pOrdField, input[i].parentOrdinal);

      jenv->SetObjectArrayElement(result, i, ser);
    }

    return result;
  }
  


  struct jni_parseddocument_info {
    jclass pdClazz;
    jmethodID pdConstructor;

    jclass stringClazz;
    jclass byteArrayClazz;

    jclass mapClazz;
    jmethodID mapConstructor;
    jmethodID putMethod;

    jclass teClazz;
    jmethodID teConstructor;

    jfieldID termsField;
    jfieldID textField;
    jfieldID contentField;
    jfieldID positionsField;
    jfieldID metadataField;

    jfieldID beginField;
    jfieldID endField;
  };

  void parseddocument_init( JNIEnv* jenv, jni_parseddocument_info& info ) {
    info.pdClazz = jenv->FindClass("lemurproject/indri/ParsedDocument");
    info.pdConstructor = jenv->GetMethodID(info.pdClazz, "<init>", "()V" );

    info.stringClazz = jenv->FindClass("java/lang/String" );
    info.byteArrayClazz = jenv->FindClass("[B" );

    info.mapClazz = jenv->FindClass("java/util/HashMap");
    info.mapConstructor = jenv->GetMethodID(info.mapClazz, "<init>", "()V" );

    info.putMethod = jenv->GetMethodID(info.mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
    info.teClazz = jenv->FindClass("lemurproject/indri/ParsedDocument$TermExtent" );
    info.teConstructor = jenv->GetMethodID(info.teClazz, "<init>", "(II)V" );

    info.textField = jenv->GetFieldID(info.pdClazz, "text", "Ljava/lang/String;" );
    info.contentField = jenv->GetFieldID(info.pdClazz, "content", "Ljava/lang/String;" );
    info.termsField = jenv->GetFieldID(info.pdClazz, "terms", "[Ljava/lang/String;" );
    info.positionsField = jenv->GetFieldID(info.pdClazz, "positions", "[Llemurproject/indri/ParsedDocument$TermExtent;" );
    info.metadataField = jenv->GetFieldID(info.pdClazz, "metadata", "Ljava/util/Map;" );

    info.beginField = jenv->GetFieldID(info.teClazz, "begin", "I");
    info.endField = jenv->GetFieldID(info.teClazz, "end", "I");
  }

  jobject parseddocument_copy( JNIEnv* jenv, jni_parseddocument_info& info, indri::api::ParsedDocument* doc ) {
    // make a parsed document
    jobject result = jenv->NewObject(info.pdClazz, info.pdConstructor);

    // make a metadata map to go in it
    jobject mapObject = jenv->NewObject(info.mapClazz, info.mapConstructor);

    // copy metadata information
    for( unsigned int i=0; i<doc->metadata.size(); i++ ) {
      indri::parse::MetadataPair& pair = doc->metadata[i];

      jstring key = jenv->NewStringUTF(pair.key);
      jbyteArray value = jenv->NewByteArray(pair.valueLength);

      jbyte* elements = jenv->GetByteArrayElements(value, 0);
      memcpy( elements, pair.value, pair.valueLength );
      jenv->ReleaseByteArrayElements(value, elements, 0);

      // put it in the map
      jenv->CallObjectMethod(mapObject, info.putMethod, key, value);
    }

    // make a terms string array
    jobjectArray termsArray = jenv->NewObjectArray(doc->terms.size(), info.stringClazz, NULL);

    // copy terms information
    for( unsigned int i=0; i<doc->terms.size(); i++ ) {
      jstring term = jenv->NewStringUTF(doc->terms[i]);
      jenv->SetObjectArrayElement(termsArray, i, term);
    }

    // make a positions array
    jobjectArray positionsArray = jenv->NewObjectArray(doc->positions.size(), info.teClazz, NULL);

    // copy positions information
    for( unsigned int i=0; i<doc->positions.size(); i++ ) {
      int begin = doc->positions[i].begin;
      int end = doc->positions[i].end;
      jobject position = jenv->NewObject(info.teClazz, info.teConstructor, begin, end);

      // add this object to the array
      jenv->SetObjectArrayElement(positionsArray, i, position);
    }

    // store field data
    jstring text = jenv->NewStringUTF(doc->text);

    jenv->SetObjectField(result, info.textField, text);

    // this makes a copy...
    jstring content = jenv->NewStringUTF(doc->getContent().c_str());

    jenv->SetObjectField(result, info.contentField, content);

    jenv->SetObjectField(result, info.termsField, termsArray);
    jenv->SetObjectField(result, info.positionsField, positionsArray);
    jenv->SetObjectField(result, info.metadataField, mapObject);

    return result;
  }

  


  jobject java_build_queryannotationnode( indri::api::QueryAnnotationNode* in,
                                          JNIEnv* jenv,
                                          jclass qanClazz,
                                          jmethodID qanConst ) {
    jobjectArray children = jenv->NewObjectArray(in->children.size(), qanClazz, NULL);

    for( unsigned int i=0; i<in->children.size(); i++ ) {
      jobject child = java_build_queryannotationnode( in->children[i], jenv, qanClazz, qanConst );
      jenv->SetObjectArrayElement(children, i, child);
    }

    jstring name = jenv->NewStringUTF(in->name.c_str());
    jstring type = jenv->NewStringUTF(in->type.c_str());
    jstring queryText = jenv->NewStringUTF(in->queryText.c_str());

    jobject node = jenv->NewObject(qanClazz, qanConst, name, type, queryText, children);

    return node;
  }

  


  struct jni_parameters_info {
    jclass stringClazz;
    jclass mapClazz;
    jclass setClazz;
    jclass arrayOfMaps;
    jclass arrayOfString;
  };

  void java_parameters_map( JNIEnv* jenv, jni_parameters_info& info, indri::api::Parameters p, jobject obj );
  void java_parameters_array_of_maps( JNIEnv* jenv, jni_parameters_info& info, indri::api::Parameters p, const std::string& key, jobjectArray array );

  void java_parameters_init( JNIEnv* jenv, jni_parameters_info& info ) {
    info.stringClazz = jenv->FindClass("java/lang/String");
    info.mapClazz = jenv->FindClass("java/util/Map");
    info.setClazz = jenv->FindClass("java/util/Set");
    info.arrayOfMaps = jenv->FindClass("[Ljava/util/Map;");
    info.arrayOfString = jenv->FindClass("[Ljava/lang/String;");
  }

  void java_parameters_array_of_strings( JNIEnv* jenv, jni_parameters_info& info, indri::api::Parameters p, const std::string& key, jobjectArray array ) {
    // get the array size
    jsize arrayLength = jenv->GetArrayLength(array);

    for( int i=0; i<arrayLength; i++ ) {
      jstring s = (jstring) jenv->GetObjectArrayElement( array, i );
    
      const char* valueBytes = jenv->GetStringUTFChars(s, 0);
      std::string valueString = (const char*) valueBytes;
      jenv->ReleaseStringUTFChars(s, valueBytes);
    
      p.append(key).set(valueString);
    }
  }

  void java_parameters_array_of_maps( JNIEnv* jenv, jni_parameters_info& info, indri::api::Parameters p, const std::string& key, jobjectArray array ) {
    // get the array size
    jsize arrayLength = jenv->GetArrayLength(array);

    for( int i=0; i<arrayLength; i++ ) {
      jobject obj = jenv->GetObjectArrayElement( array, i );
      java_parameters_map( jenv, info, p, obj );
    }
  }

  void java_parameters_map( JNIEnv* jenv, jni_parameters_info& info, indri::api::Parameters p, jobject mapObj ) {
    // get map class and entrySet method pointer
    jclass mapClazz = jenv->GetObjectClass(mapObj);
    jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );

    // call entry set function to set a Set of entries
    jobject entrySet = jenv->CallObjectMethod(mapObj, mapEntrySet);
    jclass setClazz = jenv->GetObjectClass(entrySet);
    jmethodID setToArray = jenv->GetMethodID(setClazz, "toArray", "()[Ljava/lang/Object;" );

    // turn that set into an array of objects (entries)
    jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod(entrySet, setToArray);

    // get the array size
    jsize entryArrayLength = jenv->GetArrayLength(entryArray);

    for( int i=0; i<entryArrayLength; i++ ) {
      // get the key string
      jobject entryObject = (jstring) jenv->GetObjectArrayElement( entryArray, i );
      jclass mapEntryClazz = jenv->GetObjectClass(entryObject);
      jmethodID mapEntryGetKey = jenv->GetMethodID(mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
      jmethodID mapEntryGetValue = jenv->GetMethodID(mapEntryClazz, "getValue", "()Ljava/lang/Object;" );

      // get key string
      jstring key = (jstring) jenv->CallObjectMethod(entryObject, mapEntryGetKey);
      const char* bytes = jenv->GetStringUTFChars(key, 0);
      std::string keyString = (const char*) bytes;
      jenv->ReleaseStringUTFChars(key, bytes);
    
      // get value object
      jobject value = jenv->CallObjectMethod(entryObject, mapEntryGetValue);
    
      // figure out object type
      if( jenv->IsInstanceOf( value, info.stringClazz ) ) {
        const char* valueBytes = jenv->GetStringUTFChars( (jstring)value, 0);
        std::string valueString = (const char*) valueBytes;
        jenv->ReleaseStringUTFChars( (jstring)value, valueBytes);
      
        p.set( keyString, valueString );
      } else if( jenv->IsInstanceOf( value, info.mapClazz ) ) {
        indri::api::Parameters sub = p.append( keyString );
        java_parameters_map( jenv, info, p, value );
      } else if( jenv->IsInstanceOf( value, info.arrayOfMaps ) ) {
        java_parameters_array_of_maps( jenv, info, p, keyString, (jobjectArray) value );
      } else if( jenv->IsInstanceOf( value, info.arrayOfString ) ) {
        java_parameters_array_of_strings( jenv, info, p, keyString, (jobjectArray) value );
      } else {
        SWIG_JavaException(jenv, SWIG_RuntimeError, "Found something in a Parameters parameter that wasn't a String, Map, String[] or Map[]." );
      }
    }
  }

  


  jobject documentvector_copy( JNIEnv* jenv, indri::api::DocumentVector* vec ) {
    jobject result;

    jclass stringClazz = jenv->FindClass( "java/lang/String" );
    jclass docVectorClazz = jenv->FindClass( "lemurproject/indri/DocumentVector" );
    jclass fieldClazz = jenv->FindClass( "lemurproject/indri/DocumentVector$Field" );

    jfieldID beginField = jenv->GetFieldID( fieldClazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID( fieldClazz, "end", "I" );
    jfieldID numberField = jenv->GetFieldID( fieldClazz, "number", "J" );
    jfieldID ordinalField = jenv->GetFieldID( fieldClazz, "ordinal", "I" );
    jfieldID parentOrdinalField = jenv->GetFieldID( fieldClazz, "parentOrdinal", "I" );
    jfieldID nameField = jenv->GetFieldID( fieldClazz, "name", "Ljava/lang/String;" );

    jfieldID stemsField = jenv->GetFieldID( docVectorClazz, "stems", "[Ljava/lang/String;" );
    jfieldID positionsField = jenv->GetFieldID( docVectorClazz, "positions", "[I" );
    jfieldID fieldsField = jenv->GetFieldID( docVectorClazz, "fields", "[Llemurproject/indri/DocumentVector$Field;" );
  
    jmethodID fieldConstructor = jenv->GetMethodID( fieldClazz, "<init>", "()V" );
    jmethodID docVecConstructor = jenv->GetMethodID( docVectorClazz, "<init>", "()V" );

    int stemsCount = vec->stems().size();
    int positionsCount = vec->positions().size();
    int fieldsCount = vec->fields().size();
  
    // store positions
    jintArray posArray = jenv->NewIntArray( positionsCount );
    jint* posElements = jenv->GetIntArrayElements( posArray, 0 );

    for( int i=0; i<positionsCount; i++ ) {
      posElements[i] = vec->positions()[i];
    }

    jenv->ReleaseIntArrayElements( posArray, posElements, 0 );

    // store stems
    jobjectArray stemArray = jenv->NewObjectArray( stemsCount, stringClazz, 0 );

    for( int i=0; i<stemsCount; i++ ) {
      jstring s = jenv->NewStringUTF( vec->stems()[i].c_str() );
      jenv->SetObjectArrayElement( stemArray, i, s );
    }
  
    // store fields
    jobjectArray fieldsArray = jenv->NewObjectArray( fieldsCount, fieldClazz, 0 );
  
    for( int i=0; i<fieldsCount; i++ ) {
      // make a field object
      jobject f = jenv->NewObject( fieldClazz, fieldConstructor );
      jstring name = jenv->NewStringUTF( vec->fields()[i].name.c_str() );
    
      jenv->SetIntField( f, beginField, vec->fields()[i].begin );
      jenv->SetIntField( f, endField, vec->fields()[i].end );
      jenv->SetIntField( f, ordinalField, vec->fields()[i].ordinal );
      jenv->SetIntField( f, parentOrdinalField, vec->fields()[i].parentOrdinal );
      jenv->SetLongField( f, numberField, vec->fields()[i].number );
      jenv->SetObjectField( f, nameField, name );
  
      // put it in the array
      jenv->SetObjectArrayElement( fieldsArray, i, f );
    }
    // don't delete this twice.
    //  delete vec;
  
    // build the document vector object
    result = jenv->NewObject( docVectorClazz, docVecConstructor );

    // store fields
    jenv->SetObjectField( result, stemsField, stemArray );
    jenv->SetObjectField( result, positionsField, posArray );
    jenv->SetObjectField( result, fieldsField, fieldsArray );

    return result;
  }

  

  struct jni_specification_info {
    // Specification
    jclass specClazz;
    jmethodID specConstructor;
    jfieldID nameField;
    jfieldID tokenizerField;
    jfieldID parserField;
    jfieldID iteratorField;
    jfieldID startDocTagField;
    jfieldID endDocTagField;
    jfieldID endMetadataTagField;
    jfieldID includeField;
    jfieldID excludeField;
    jfieldID indexField;
    jfieldID metadataField;
    jfieldID conflationsField;
    // support classes
    jclass mapClazz;
    jmethodID mapConstructor;
    jmethodID putMethod;
  };
 
  void print_info(jni_specification_info& info) 
    {
      std::cerr << info.specClazz << std::endl;
      std::cerr << info.specConstructor << std::endl;
      // get all the fields
      std::cerr << info.nameField << std::endl;
      std::cerr << info.tokenizerField << std::endl;
      std::cerr << info.parserField << std::endl;
      std::cerr << info.iteratorField << std::endl;
      std::cerr << info.startDocTagField << std::endl;
      std::cerr << info.endDocTagField << std::endl;
      std::cerr << info.endMetadataTagField << std::endl;
      std::cerr << info.includeField << std::endl;
      std::cerr << info.excludeField << std::endl;
      std::cerr << info.indexField << std::endl;
      std::cerr << info.metadataField << std::endl;
      std::cerr << info.conflationsField << std::endl;
      std::cerr << info.mapClazz << std::endl;
      std::cerr << info.mapConstructor << std::endl;
      std::cerr << info.putMethod << std::endl;
    }
 
  void specification_init( JNIEnv* jenv, jni_specification_info& info ) {

    info.specClazz = jenv->FindClass("lemurproject/indri/Specification");
    info.specConstructor = jenv->GetMethodID(info.specClazz, "<init>", "()V" );
    // get all the fields
    info.nameField = jenv->GetFieldID(info.specClazz, "name", "Ljava/lang/String;");
    info.tokenizerField = jenv->GetFieldID(info.specClazz, "tokenizer", "Ljava/lang/String;");  
    info.parserField = jenv->GetFieldID(info.specClazz, "parser", "Ljava/lang/String;");
    info.iteratorField = jenv->GetFieldID(info.specClazz, "iterator", "Ljava/lang/String;");
    info.startDocTagField = jenv->GetFieldID(info.specClazz, "startDocTag", "Ljava/lang/String;");
    info.endDocTagField = jenv->GetFieldID(info.specClazz, "endDocTag", "Ljava/lang/String;");
    info.endMetadataTagField = jenv->GetFieldID(info.specClazz, "endMetadataTag", "Ljava/lang/String;");
    info.includeField = jenv->GetFieldID(info.specClazz, "include", "[Ljava/lang/String;");
    info.excludeField = jenv->GetFieldID(info.specClazz, "exclude", "[Ljava/lang/String;");
    info.indexField = jenv->GetFieldID(info.specClazz, "index", "[Ljava/lang/String;");
    info.metadataField = jenv->GetFieldID(info.specClazz, "metadata", "[Ljava/lang/String;");
    info.conflationsField = jenv->GetFieldID(info.specClazz, "conflations", "Ljava/util/Map;");

    info.mapClazz = jenv->FindClass("java/util/HashMap");
    info.mapConstructor = jenv->GetMethodID(info.mapClazz, "<init>", "()V" );
    info.putMethod = jenv->GetMethodID(info.mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
  }

  jobjectArray string_vector_copy(JNIEnv* jenv, std::vector<std::string> &vec) {
    jclass stringClazz = jenv->FindClass("java/lang/String" );
    // fill in array  
    jobjectArray stringArray = jenv->NewObjectArray(vec.size(), stringClazz,
                                                    NULL);
    for(int i = 0; i < vec.size(); i++ ) {
      jstring val = jenv->NewStringUTF(vec[i].c_str());
      jenv->SetObjectArrayElement(stringArray, i, val);
    }
    return stringArray;
  }
 
  jobject specification_copy( JNIEnv* jenv, jni_specification_info& info, 
                              indri::parse::FileClassEnvironmentFactory::Specification* thisSpec ) {
    jobject result = jenv->NewObject(info.specClazz, info.specConstructor);
    // initialize the fields
    jstring stringField;
    stringField = jenv->NewStringUTF(thisSpec->name.c_str());
    jenv->SetObjectField(result, info.nameField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->tokenizer.c_str());
    jenv->SetObjectField(result, info.tokenizerField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->parser.c_str());
    jenv->SetObjectField(result, info.parserField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->iterator.c_str());
    jenv->SetObjectField(result, info.iteratorField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->startDocTag.c_str());
    jenv->SetObjectField(result, info.startDocTagField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->endDocTag.c_str());
    jenv->SetObjectField(result, info.endDocTagField, stringField);
    stringField = jenv->NewStringUTF(thisSpec->endMetadataTag.c_str());
    jenv->SetObjectField(result, info.endMetadataTagField, stringField);
    // make a conflations map to go in it

    jclass conflationClazz = jenv->FindClass("lemurproject/indri/ConflationPattern");
    jmethodID conflationConstructor = jenv->GetMethodID(conflationClazz, "<init>", "()V" ); 
    jfieldID tag_nameField = jenv->GetFieldID(conflationClazz, "tag_name", "Ljava/lang/String;" );
    jfieldID attribute_nameField = jenv->GetFieldID(conflationClazz, "attribute_name", "Ljava/lang/String;"  );
    jfieldID valueField = jenv->GetFieldID(conflationClazz, "value", "Ljava/lang/String;" );

    jobject mapObject = jenv->NewObject(info.mapClazz, info.mapConstructor);
    for( std::map<indri::parse::ConflationPattern *, std::string>::iterator iter = thisSpec->conflations.begin(); 
         iter != thisSpec->conflations.end(); iter++ ) {
      const indri::parse::ConflationPattern *thisKey = iter->first;
      const std::string &thisVal = iter->second;
      jobject patternObject = jenv->NewObject(conflationClazz, conflationConstructor);
      jstring patVal;
      const char *c_str = thisKey->tag_name;
      if (c_str == NULL) c_str = ""; // don't give NewStringUTF a NULL.
      patVal = jenv->NewStringUTF(c_str);
      jenv->SetObjectField(patternObject, tag_nameField, patVal);
      c_str = thisKey->attribute_name;
      if (c_str == NULL) c_str = ""; // don't give NewStringUTF a NULL.
      patVal = jenv->NewStringUTF(c_str);
      jenv->SetObjectField(patternObject, attribute_nameField, patVal);
      c_str = thisKey->value;
      if (c_str == NULL) c_str = ""; // don't give NewStringUTF a NULL.
      patVal = jenv->NewStringUTF(c_str);
      jenv->SetObjectField(patternObject, valueField, patVal);

      jstring val = jenv->NewStringUTF(thisVal.c_str());
      jenv->CallObjectMethod(mapObject, info.putMethod, patternObject, val);
    }
    jenv->SetObjectField(result, info.conflationsField, mapObject);
    jobjectArray stringArray = string_vector_copy(jenv, thisSpec->include);
    jenv->SetObjectField(result, info.includeField, stringArray);
    stringArray = string_vector_copy(jenv, thisSpec->exclude);
    jenv->SetObjectField(result, info.excludeField, stringArray);
    stringArray = string_vector_copy(jenv, thisSpec->index);
    jenv->SetObjectField(result, info.indexField, stringArray);
    stringArray = string_vector_copy(jenv, thisSpec->metadata);
    jenv->SetObjectField(result, info.metadataField, stringArray);
    return result;
  }

  // copy to string
  void copy_to_string(JNIEnv* jenv, jstring src, std::string &target) {
    jsize stringLength = jenv->GetStringUTFLength(src);
    const char* stringChars = jenv->GetStringUTFChars(src, 0);
    target.assign( stringChars, stringChars + stringLength );
  }

  // copy to string vector (stringvector.i)
  void copy_to_string_vector(JNIEnv* jenv, jobjectArray src, 
                             std::vector<std::string> &target) {
    jsize arrayLength = jenv->GetArrayLength(src);
    for( unsigned int i = 0; i < arrayLength; i++ ) {
      std::string stringCopy;
      jstring str = (jstring) jenv->GetObjectArrayElement(src, i);
      copy_to_string(jenv, str, stringCopy);    
      target.push_back(stringCopy);
    }
  }
 
  // copy to map (stringmap.i)
  void copy_to_map(JNIEnv* jenv, jobject src,
                   std::map<indri::parse::ConflationPattern*, std::string> &map) {

    // get map class and entrySet method pointer
    jclass mapClazz = jenv->GetObjectClass(src);
    jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );

    // call entry set function to set a Set of entries
    jobject entrySet = jenv->CallObjectMethod(src, mapEntrySet);
    jclass setClazz = jenv->GetObjectClass(entrySet);
    jmethodID setToArray = jenv->GetMethodID(setClazz, "toArray", "()[Ljava/lang/Object;" );

    // turn that set into an array of objects (entries)
    jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod(entrySet, setToArray);

    // get the array size
    jsize entryArrayLength = jenv->GetArrayLength(entryArray);

    jclass conflationClazz = jenv->FindClass("lemurproject/indri/ConflationPattern");
    jfieldID tag_nameField = jenv->GetFieldID(conflationClazz, "tag_name", "Ljava/lang/String;" );
    jfieldID attribute_nameField = jenv->GetFieldID(conflationClazz, "attribute_name", "Ljava/lang/String;"  );
    jfieldID valueField = jenv->GetFieldID(conflationClazz, "value", "Ljava/lang/String;" );

    for( int i=0; i<entryArrayLength; i++ ) {
      // get the key string
      jobject entryObject = (jstring) jenv->GetObjectArrayElement( entryArray, i );
      jclass mapEntryClazz = jenv->GetObjectClass(entryObject);
      jmethodID mapEntryGetKey = jenv->GetMethodID(mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
      jmethodID mapEntryGetValue = jenv->GetMethodID(mapEntryClazz, "getValue", "()Ljava/lang/Object;" );

      jobject key = jenv->CallObjectMethod( entryObject, mapEntryGetKey );
      jobject value = jenv->CallObjectMethod( entryObject, mapEntryGetValue );
    
      indri::parse::ConflationPattern * pattern = new indri::parse::ConflationPattern();

      const char* valueChars = jenv->GetStringUTFChars( (jstring) value, 0 );
      std::string valueString = valueChars;
      jenv->ReleaseStringUTFChars( (jstring) value, valueChars );

      jstring fieldValue = (jstring) jenv->GetObjectField(key, tag_nameField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->tag_name = valueChars;
  
      fieldValue = (jstring) jenv->GetObjectField(key, attribute_nameField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->attribute_name = valueChars;

      fieldValue = (jstring) jenv->GetObjectField(key, valueField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->value = valueChars;
      map[pattern] = valueString ;
    }
  }
 
  

  jobject queryresults_copy(JNIEnv *jenv, indri::api::QueryResults &results) 
    {
      jobject result = NULL;
      // get java class
      jclass clazz = jenv->FindClass("lemurproject/indri/QueryResults");
      jmethodID constructor = jenv->GetMethodID(clazz, "<init>", "()V" );
      jfieldID parseTimeField = jenv->GetFieldID(clazz, "parseTime", "D" );
      jfieldID executeTimeField = jenv->GetFieldID(clazz, "executeTime", "D" );
      jfieldID documentsTimeField = jenv->GetFieldID(clazz, "documentsTime", "D" );
      jfieldID estMatchesField = jenv->GetFieldID(clazz, "estimatedMatches", "I" );
      jfieldID resultsField = jenv->GetFieldID(clazz, "results", "[Llemurproject/indri/QueryResult;" );

      result = jenv->NewObject(clazz, constructor);
      jenv->SetDoubleField(result, parseTimeField, results.parseTime );
      jenv->SetDoubleField(result, executeTimeField, results.executeTime );
      jenv->SetDoubleField(result, documentsTimeField, results.documentsTime );
      jenv->SetIntField(result, estMatchesField, results.estimatedMatches );

      jclass qrClazz = jenv->FindClass("lemurproject/indri/QueryResult");
      jmethodID qrConstructor = jenv->GetMethodID(qrClazz, "<init>", "()V" );
      jfieldID snippetField = jenv->GetFieldID(qrClazz, "snippet", "Ljava/lang/String;" );
      jfieldID docNameField = jenv->GetFieldID(qrClazz, "documentName", "Ljava/lang/String;" );
      jfieldID docidField = jenv->GetFieldID(qrClazz, "docid", "I" );
      jfieldID scoreField = jenv->GetFieldID(qrClazz, "score", "D" );
      jfieldID beginField = jenv->GetFieldID(qrClazz, "begin", "I" );
      jfieldID endField = jenv->GetFieldID(qrClazz, "end", "I" );
      jfieldID metadataField = jenv->GetFieldID(qrClazz, "metadata", "Ljava/util/Map;" );
      jobjectArray resultArray = jenv->NewObjectArray(results.results.size(), qrClazz, NULL);
      jenv->SetObjectField(result, resultsField, resultArray);

      jclass mapClazz = jenv->FindClass("java/util/HashMap");
      jmethodID mapConstructor = jenv->GetMethodID(mapClazz, "<init>", "()V" );
      jmethodID putMethod = jenv->GetMethodID(mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );

      for (jsize i = 0; i < results.results.size(); i++) {
        jobject qr = jenv->NewObject(qrClazz, qrConstructor);
        //populate fields
        jstring snippet = jenv->NewStringUTF(results.results[i].snippet.c_str());
        jstring documentName = jenv->NewStringUTF(results.results[i].documentName.c_str());;
        jenv->SetObjectField(qr, snippetField, snippet);
        jenv->SetObjectField(qr, docNameField, documentName);
        jenv->SetIntField(qr, docidField, results.results[i].docid );

        jenv->SetDoubleField(qr, scoreField, results.results[i].score );
        jenv->SetIntField(qr, beginField, results.results[i].begin );
        jenv->SetIntField(qr, endField, results.results[i].end );

        // metadata is a Map, bleah... make a hashmap and populate it.
        jobject mapObject = jenv->NewObject(mapClazz, mapConstructor);

        // copy metadata information
        for( unsigned int j = 0; j < results.results[i].metadata.size(); j++) {
          indri::api::MetadataPair& pair = results.results[i].metadata[j];
          jstring key = jenv->NewStringUTF(pair.key.c_str());
          jstring value = jenv->NewStringUTF(pair.value.c_str());
          // put it in the map
          jenv->CallObjectMethod(mapObject, putMethod, key, value);
        }
        jenv->SetObjectField(qr, metadataField, mapObject);
        jenv->SetObjectArrayElement(resultArray, i, qr);
      }
      return result;
    }


#include "indri/TagList.hpp"



/* ---------------------------------------------------
 * C++ director class methods
 * --------------------------------------------------- */

#include "indri_jni.h"

SwigDirector_IndexStatus::SwigDirector_IndexStatus(JNIEnv *jenv) : indri::api::IndexStatus(), Swig::Director(jenv) {
}

SwigDirector_IndexStatus::~SwigDirector_IndexStatus() {
  swig_disconnect_director_self("swigDirectorDisconnect");
}


void SwigDirector_IndexStatus::status(int code, std::string const &documentPath, std::string const &error, int documentsIndexed, int documentsSeen) {
  JNIEnvWrapper swigjnienv(this) ;
  JNIEnv * jenv = swigjnienv.getJNIEnv() ;
  jobject swigjobj = (jobject) NULL ;
  jint jcode  ;
  jstring jdocumentPath = 0 ;
  jstring jerror = 0 ;
  jint jdocumentsIndexed  ;
  jint jdocumentsSeen  ;
  
  if (!swig_override[0]) {
    SWIG_JavaThrowException(JNIEnvWrapper(this).getJNIEnv(), SWIG_JavaDirectorPureVirtual, "Attempted to invoke pure virtual method indri::api::IndexStatus::status.");
    return;
  }
  swigjobj = swig_get_self(jenv);
  if (swigjobj && jenv->IsSameObject(swigjobj, NULL) == JNI_FALSE) {
    jcode = (jint) code;
    jdocumentPath = jenv->NewStringUTF((&documentPath)->c_str()); 
    jerror = jenv->NewStringUTF((&error)->c_str()); 
    jdocumentsIndexed = (jint) documentsIndexed;
    jdocumentsSeen = (jint) documentsSeen;
    jenv->CallStaticVoidMethod(Swig::jclass_indriJNI, Swig::director_methids[0], swigjobj, jcode, jdocumentPath, jerror, jdocumentsIndexed, jdocumentsSeen);
    if (jenv->ExceptionOccurred()) return ;
  } else {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null upcall object");
  }
  if (swigjobj) jenv->DeleteLocalRef(swigjobj);
}

void SwigDirector_IndexStatus::swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global) {
  static struct {
    const char *mname;
    const char *mdesc;
    jmethodID base_methid;
  } methods[] = {
    {
      "status", "(ILjava/lang/String;Ljava/lang/String;II)V", NULL 
    }
  };
  
  static jclass baseclass = 0 ;
  
  if (swig_set_self(jenv, jself, swig_mem_own, weak_global)) {
    if (!baseclass) {
      baseclass = jenv->FindClass("lemurproject/indri/IndexStatus");
      if (!baseclass) return;
      baseclass = (jclass) jenv->NewGlobalRef(baseclass);
    }
    bool derived = (jenv->IsSameObject(baseclass, jcls) ? false : true);
    for (int i = 0; i < 1; ++i) {
      if (!methods[i].base_methid) {
        methods[i].base_methid = jenv->GetMethodID(baseclass, methods[i].mname, methods[i].mdesc);
        if (!methods[i].base_methid) return;
      }
      swig_override[i] = false;
      if (derived) {
        jmethodID methid = jenv->GetMethodID(jcls, methods[i].mname, methods[i].mdesc);
        swig_override[i] = (methid != methods[i].base_methid);
        jenv->ExceptionClear();
      }
    }
  }
}



#ifdef __cplusplus
extern "C" {
#endif

SWIGEXPORT jobject JNICALL Java_lemurproject_indri_indriJNI_QueryAnnotation_1getQueryTree(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobject jresult = 0 ;
  indri::api::QueryAnnotation *arg1 = (indri::api::QueryAnnotation *) 0 ;
  indri::api::QueryAnnotationNode *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryAnnotation **)&jarg1; 
  {
    try {
      try {
        result = (indri::api::QueryAnnotationNode *)((indri::api::QueryAnnotation const *)arg1)->getQueryTree();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jclass qanClazz = jenv->FindClass("lemurproject/indri/QueryAnnotationNode" );
    const char* signature = "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;[Llemurproject/indri/QueryAnnotationNode;)V";
    jmethodID qanConst = jenv->GetMethodID(qanClazz, "<init>", signature );
    
    jresult = java_build_queryannotationnode( result,
      jenv,
      qanClazz,
      qanConst );
  }
  return jresult;
}


SWIGEXPORT jobject JNICALL Java_lemurproject_indri_indriJNI_QueryAnnotation_1getAnnotations(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobject jresult = 0 ;
  indri::api::QueryAnnotation *arg1 = (indri::api::QueryAnnotation *) 0 ;
  indri::infnet::EvaluatorNode::MResults *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryAnnotation **)&jarg1; 
  {
    try {
      try {
        result = (indri::infnet::EvaluatorNode::MResults *) &((indri::api::QueryAnnotation const *)arg1)->getAnnotations();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    indri::infnet::EvaluatorNode::MResults::iterator iter;
    
    // make the map
    jclass mapClazz = jenv->FindClass("java/util/HashMap");
    jmethodID mapConstructor = jenv->GetMethodID(mapClazz, "<init>", "()V" );
    jresult = jenv->NewObject(mapClazz, mapConstructor);
    jmethodID putMethod = jenv->GetMethodID(mapClazz, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;" );
    
    // look up information about ScoredExtentResults
    jclass seClazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jmethodID seConstructor = jenv->GetMethodID(seClazz, "<init>", "()V" );
    
    jfieldID scoreField = jenv->GetFieldID(seClazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(seClazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(seClazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(seClazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(seClazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(seClazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(seClazz, "parentOrdinal", "I");
    
    for( iter = result->begin(); iter != result->end(); iter++ ) {
      std::vector<indri::api::ScoredExtentResult>& vec = iter->second;
      
      // make an array for this list of results
      jobjectArray array = jenv->NewObjectArray(vec.size(), seClazz, NULL);
      
      for( unsigned int i=0; i<vec.size(); i++ ) {
        // make a new scored extent result object
        jobject ser = jenv->NewObject(seClazz, seConstructor);
        
        // fill in the fields
        jenv->SetDoubleField(ser, scoreField, vec[i].score );
        jenv->SetIntField(ser, beginField, vec[i].begin );
        jenv->SetIntField(ser, endField, vec[i].end );
        jenv->SetIntField(ser, documentField, vec[i].document );
        jenv->SetLongField(ser, numberField, vec[i].number);
        jenv->SetIntField(ser, ordField, vec[i].ordinal);
        jenv->SetIntField(ser, pOrdField, vec[i].parentOrdinal);
        
        // add this object to the array
        jenv->SetObjectArrayElement(array, i, ser);
      }
      
      // make a java string for this result list name
      jstring key = jenv->NewStringUTF(iter->first.c_str());
      // add the java array to the map
      jenv->CallObjectMethod(jresult, putMethod, key, array);
    }
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryAnnotation_1getResults(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobjectArray jresult = 0 ;
  indri::api::QueryAnnotation *arg1 = (indri::api::QueryAnnotation *) 0 ;
  std::vector< indri::api::ScoredExtentResult > *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryAnnotation **)&jarg1; 
  {
    try {
      try {
        result = (std::vector< indri::api::ScoredExtentResult > *) &((indri::api::QueryAnnotation const *)arg1)->getResults();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, *(result) );
  }
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1QueryAnnotation(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  indri::api::QueryAnnotation *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    try {
      result = (indri::api::QueryAnnotation *)new indri::api::QueryAnnotation();
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::QueryAnnotation **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1QueryAnnotation(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::api::QueryAnnotation *arg1 = (indri::api::QueryAnnotation *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::api::QueryAnnotation **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1QueryEnvironment(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    try {
      result = (indri::api::QueryEnvironment *)new indri::api::QueryEnvironment();
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::QueryEnvironment **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1addServer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->addServer((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1addIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->addIndex((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1removeServer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->removeServer((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1removeIndex(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->removeIndex((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1close(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      try {
        (arg1)->close();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1setMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  UINT64 arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  arg2 = (UINT64)jarg2; 
  {
    try {
      try {
        (arg1)->setMemory(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1setScoringRules(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > strin2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    arg2 = &strin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg2->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        (arg1)->setScoringRules((std::vector< std::string > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1setStopwords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > strin2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    arg2 = &strin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg2->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        (arg1)->setStopwords((std::vector< std::string > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1runQuery_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = (int)jarg3; 
  {
    try {
      try {
        result = (arg1)->runQuery((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1runQuery_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jintArray jarg3, jint jarg4) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  int arg4 ;
  std::vector< int > typemapin3 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg3);
    jint* elements = jenv->GetIntArrayElements(jarg3, 0);
    arg3 = &typemapin3;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      arg3->push_back(elements[i]);
    }
    
    jenv->ReleaseIntArrayElements(jarg3, elements, 0);
  }
  arg4 = (int)jarg4; 
  {
    try {
      try {
        result = (arg1)->runQuery((std::string const &)*arg2,(std::vector< int > const &)*arg3,arg4);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jobject JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1runQuery_1_1SWIG_12(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jobject jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  indri::api::QueryRequest *arg2 = 0 ;
  indri::api::QueryRequest req2 ;
  indri::api::QueryResults result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    arg2 = &req2;
    jclass qrClazz = jenv->FindClass("lemurproject/indri/QueryRequest");
    jfieldID queryField = jenv->GetFieldID(qrClazz, "query",  "Ljava/lang/String;");
    
    jfieldID formulatorsField = jenv->GetFieldID(qrClazz, "formulators", "[Ljava/lang/String;");
    jfieldID metadataField = jenv->GetFieldID(qrClazz, "metadata", "[Ljava/lang/String;");
    jfieldID resultsRequestedField = jenv->GetFieldID(qrClazz, "resultsRequested", "I");
    jfieldID startNumField = jenv->GetFieldID(qrClazz, "startNum", "I");
    jfieldID optionsField = jenv->GetFieldID(qrClazz, "options", "I");
    
    jstring query = (jstring) jenv->GetObjectField(jarg2, queryField);
    
    jobjectArray formulators = (jobjectArray) jenv->GetObjectField(jarg2, formulatorsField);
    
    jobjectArray metadata = (jobjectArray) jenv->GetObjectField(jarg2, metadataField);
    jint resultsRequested = jenv->GetIntField(jarg2, resultsRequestedField);
    jint startNum = jenv->GetIntField(jarg2, startNumField);
    jint options = jenv->GetIntField(jarg2, optionsField);
    
    // fill in the values
    const char *queryString = jenv->GetStringUTFChars(query, 0);
    req2.query = queryString;
    jenv->ReleaseStringUTFChars(query, queryString);
    
    jsize formCount = formulators ? jenv->GetArrayLength(formulators) : 0;
    for (int i = 0; i < formCount; i++) {
      jstring form = (jstring) jenv->GetObjectArrayElement(formulators, i);
      const char *formString = jenv->GetStringUTFChars(form, 0);
      req2.formulators.push_back(formString);
      jenv->ReleaseStringUTFChars(form, formString);
    }
    
    jsize metaCount = metadata ? jenv->GetArrayLength(metadata) : 0;
    for (int i = 0; i < metaCount; i++) {
      jstring meta = (jstring) jenv->GetObjectArrayElement(metadata, i);
      const char *metaString =  jenv->GetStringUTFChars(meta, 0);
      req2.metadata.push_back(metaString);
      jenv->ReleaseStringUTFChars(meta, metaString);
    }
    req2.resultsRequested = resultsRequested;
    req2.startNum = startNum;
    req2.options = (indri::api::QueryRequest::Options) options;
  }
  {
    try {
      try {
        result = (arg1)->runQuery(*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = queryresults_copy(jenv, result);
  }
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1runAnnotatedQuery_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  int arg3 ;
  indri::api::QueryAnnotation *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = (int)jarg3; 
  {
    try {
      try {
        result = (indri::api::QueryAnnotation *)(arg1)->runAnnotatedQuery((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::QueryAnnotation **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1runAnnotatedQuery_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jintArray jarg3, jint jarg4) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< int > *arg3 = 0 ;
  int arg4 ;
  std::vector< int > typemapin3 ;
  indri::api::QueryAnnotation *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg3);
    jint* elements = jenv->GetIntArrayElements(jarg3, 0);
    arg3 = &typemapin3;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      arg3->push_back(elements[i]);
    }
    
    jenv->ReleaseIntArrayElements(jarg3, elements, 0);
  }
  arg4 = (int)jarg4; 
  {
    try {
      try {
        result = (indri::api::QueryAnnotation *)(arg1)->runAnnotatedQuery((std::string const &)*arg2,(std::vector< int > const &)*arg3,arg4);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::QueryAnnotation **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documents_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< int > *arg2 = 0 ;
  std::vector< int > typemapin2 ;
  std::vector< indri::api::ParsedDocument * > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    jint* elements = jenv->GetIntArrayElements(jarg2, 0);
    arg2 = &typemapin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      arg2->push_back(elements[i]);
    }
    
    jenv->ReleaseIntArrayElements(jarg2, elements, 0);
  }
  {
    try {
      try {
        result = (arg1)->documents((std::vector< int > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jni_parseddocument_info info;
    parseddocument_init( jenv, info );
    
    jresult = jenv->NewObjectArray((&result)->size(), info.pdClazz, NULL);
    
    for( unsigned int i=0; i<(&result)->size(); i++ ) {
      jobject document = parseddocument_copy( jenv, info, result[i] );
      jenv->SetObjectArrayElement(jresult, i, document);
      delete result[i];
    }
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documents_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< indri::api::ScoredExtentResult > *arg2 = 0 ;
  std::vector< indri::api::ScoredExtentResult > resin2 ;
  std::vector< indri::api::ParsedDocument * > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize size = jenv->GetArrayLength(jarg2);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");
    arg2 = &resin2;
    
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg2, i);
      indri::api::ScoredExtentResult ser;
      
      ser.begin = jenv->GetIntField(seobj, beginField);
      ser.end = jenv->GetIntField(seobj, endField);
      ser.document = jenv->GetIntField(seobj, documentField);
      ser.score = jenv->GetDoubleField(seobj, scoreField);
      ser.number = jenv->GetLongField(seobj, numberField);
      ser.ordinal = jenv->GetIntField(seobj, ordField);
      ser.parentOrdinal = jenv->GetIntField(seobj, pOrdField);
      
      arg2->push_back( ser );
    }
  }
  {
    try {
      try {
        result = (arg1)->documents((std::vector< indri::api::ScoredExtentResult > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jni_parseddocument_info info;
    parseddocument_init( jenv, info );
    
    jresult = jenv->NewObjectArray((&result)->size(), info.pdClazz, NULL);
    
    for( unsigned int i=0; i<(&result)->size(); i++ ) {
      jobject document = parseddocument_copy( jenv, info, result[i] );
      jenv->SetObjectArrayElement(jresult, i, document);
      delete result[i];
    }
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentMetadata_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2, jstring jarg3) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< int > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector< int > typemapin2 ;
  SwigValueWrapper< std::vector< std::string > > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    jint* elements = jenv->GetIntArrayElements(jarg2, 0);
    arg2 = &typemapin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      arg2->push_back(elements[i]);
    }
    
    jenv->ReleaseIntArrayElements(jarg2, elements, 0);
  }
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (arg1)->documentMetadata((std::vector< int > const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    std::vector<std::string>& vec = result;
    jclass stringClazz = jenv->FindClass("java/lang/String");
    jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
    
    for( unsigned int i=0; i<vec.size(); i++ ) {
      jstring str = jenv->NewStringUTF(vec[i].c_str());
      jenv->SetObjectArrayElement( jresult, i, str);
    }
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentMetadata_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2, jstring jarg3) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< indri::api::ScoredExtentResult > *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector< indri::api::ScoredExtentResult > resin2 ;
  SwigValueWrapper< std::vector< std::string > > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize size = jenv->GetArrayLength(jarg2);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");
    arg2 = &resin2;
    
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg2, i);
      indri::api::ScoredExtentResult ser;
      
      ser.begin = jenv->GetIntField(seobj, beginField);
      ser.end = jenv->GetIntField(seobj, endField);
      ser.document = jenv->GetIntField(seobj, documentField);
      ser.score = jenv->GetDoubleField(seobj, scoreField);
      ser.number = jenv->GetLongField(seobj, numberField);
      ser.ordinal = jenv->GetIntField(seobj, ordField);
      ser.parentOrdinal = jenv->GetIntField(seobj, pOrdField);
      
      arg2->push_back( ser );
    }
  }
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (arg1)->documentMetadata((std::vector< indri::api::ScoredExtentResult > const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    std::vector<std::string>& vec = result;
    jclass stringClazz = jenv->FindClass("java/lang/String");
    jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
    
    for( unsigned int i=0; i<vec.size(); i++ ) {
      jstring str = jenv->NewStringUTF(vec[i].c_str());
      jenv->SetObjectArrayElement( jresult, i, str);
    }
  }
  return jresult;
}


SWIGEXPORT jintArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentIDsFromMetadata(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jobjectArray jarg3) {
  jintArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  std::vector< std::string > strin3 ;
  std::vector< int > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg3);
    arg3 = &strin3;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg3, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg3->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        result = (arg1)->documentIDsFromMetadata((std::string const &)*arg2,(std::vector< std::string > const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    std::vector<int> &input = result;
    jresult = jenv->NewIntArray(input.size()); 
    jint * body = jenv->GetIntArrayElements(jresult, 0);
    for( jsize i=0; i<input.size(); i++ ) {
      body[i] = input[i];
    }
    jenv->ReleaseIntArrayElements(jresult, body, 0);
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentsFromMetadata(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jobjectArray jarg3) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  std::vector< std::string > strin3 ;
  std::vector< indri::api::ParsedDocument * > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg3);
    arg3 = &strin3;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg3, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg3->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        result = (arg1)->documentsFromMetadata((std::string const &)*arg2,(std::vector< std::string > const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jni_parseddocument_info info;
    parseddocument_init( jenv, info );
    
    jresult = jenv->NewObjectArray((&result)->size(), info.pdClazz, NULL);
    
    for( unsigned int i=0; i<(&result)->size(); i++ ) {
      jobject document = parseddocument_copy( jenv, info, result[i] );
      jenv->SetObjectArrayElement(jresult, i, document);
      delete result[i];
    }
  }
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1termCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      try {
        result = (INT64)(arg1)->termCount();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1termCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (INT64)(arg1)->termCount((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1termFieldCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (INT64)(arg1)->termFieldCount((std::string const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1fieldList(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  SwigValueWrapper< std::vector< std::string > > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      try {
        result = (arg1)->fieldList();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    std::vector<std::string>& vec = result;
    jclass stringClazz = jenv->FindClass("java/lang/String");
    jresult = jenv->NewObjectArray(vec.size(), stringClazz, NULL);
    
    for( unsigned int i=0; i<vec.size(); i++ ) {
      jstring str = jenv->NewStringUTF(vec[i].c_str());
      jenv->SetObjectArrayElement( jresult, i, str);
    }
  }
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      try {
        result = (INT64)(arg1)->documentCount();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (INT64)(arg1)->documentCount((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentVectors(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jintArray jarg2) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::vector< int > *arg2 = 0 ;
  std::vector< int > typemapin2 ;
  std::vector< indri::api::DocumentVector * > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    jint* elements = jenv->GetIntArrayElements(jarg2, 0);
    arg2 = &typemapin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      arg2->push_back(elements[i]);
    }
    
    jenv->ReleaseIntArrayElements(jarg2, elements, 0);
  }
  {
    try {
      try {
        result = (arg1)->documentVectors((std::vector< int > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jclass docVecClazz = jenv->FindClass( "lemurproject/indri/DocumentVector" );
    jresult = jenv->NewObjectArray((&result)->size(), docVecClazz, NULL);
    
    for( unsigned int i=0; i<(&result)->size(); i++ ) {
      jobject vec = documentvector_copy( jenv, result[i] );
      jenv->SetObjectArrayElement(jresult, i, vec);
      delete result[i];
    }
  }
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1expressionCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jdouble jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (double)(arg1)->expressionCount((std::string const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1expressionCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jdouble jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (double)(arg1)->expressionCount((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentExpressionCount_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jdouble jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (double)(arg1)->documentExpressionCount((std::string const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jdouble JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentExpressionCount_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jdouble jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  double result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (double)(arg1)->documentExpressionCount((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jdouble)result; 
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1expressionList_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        result = (arg1)->expressionList((std::string const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1expressionList_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jobjectArray jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (arg1)->expressionList((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentLength(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  jint jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  int arg2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      try {
        result = (int)(arg1)->documentLength(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1setFormulationParameters(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  indri::api::Parameters *arg2 = 0 ;
  indri::api::Parameters p2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    if( jarg2 != 0 ) {
      jni_parameters_info info;
      java_parameters_init( jenv, info );
      
      java_parameters_map( jenv, info, p2, jarg2 );
    }   
    arg2 = &p2;
  }
  {
    try {
      (arg1)->setFormulationParameters(*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jstring JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1reformulateQuery(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      result = (arg1)->reformulateQuery((std::string const &)*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1stemTerm(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jstring jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      result = (arg1)->stemTerm((std::string const &)*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1termCountUnique(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      result = (INT64)(arg1)->termCountUnique();
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1stemCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      result = (INT64)(arg1)->stemCount((std::string const &)*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1stemFieldCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      result = (INT64)(arg1)->stemFieldCount((std::string const &)*arg2,(std::string const &)*arg3);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_QueryEnvironment_1documentStemCount(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  INT64 result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      result = (INT64)(arg1)->documentStemCount((std::string const &)*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jlong)result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1QueryEnvironment(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1QueryExpander(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::query::QueryExpander *arg1 = (indri::query::QueryExpander *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::query::QueryExpander **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryExpander_1runExpandedQuery_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3, jboolean jarg4) {
  jobjectArray jresult = 0 ;
  indri::query::QueryExpander *arg1 = (indri::query::QueryExpander *) 0 ;
  std::string arg2 ;
  int arg3 ;
  bool arg4 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::query::QueryExpander **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  } 
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  (&arg2)->assign(arg2_pstr);
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = (int)jarg3; 
  arg4 = jarg4 ? true : false; 
  {
    try {
      result = (arg1)->runExpandedQuery(arg2,arg3,arg4);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jobjectArray JNICALL Java_lemurproject_indri_indriJNI_QueryExpander_1runExpandedQuery_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jint jarg3) {
  jobjectArray jresult = 0 ;
  indri::query::QueryExpander *arg1 = (indri::query::QueryExpander *) 0 ;
  std::string arg2 ;
  int arg3 ;
  std::vector< indri::api::ScoredExtentResult > result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::query::QueryExpander **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  } 
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  (&arg2)->assign(arg2_pstr);
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = (int)jarg3; 
  {
    try {
      result = (arg1)->runExpandedQuery(arg2,arg3);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    jresult = java_build_scoredextentresult( jenv, result );
  }
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_lemurproject_indri_indriJNI_QueryExpander_1expand(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jobjectArray jarg3) {
  jstring jresult = 0 ;
  indri::query::QueryExpander *arg1 = (indri::query::QueryExpander *) 0 ;
  std::string arg2 ;
  std::vector< indri::api::ScoredExtentResult > *arg3 = 0 ;
  std::vector< indri::api::ScoredExtentResult > resin3 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::query::QueryExpander **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  } 
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  (&arg2)->assign(arg2_pstr);
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize size = jenv->GetArrayLength(jarg3);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");
    arg3 = &resin3;
    
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg3, i);
      indri::api::ScoredExtentResult ser;
      
      ser.begin = jenv->GetIntField(seobj, beginField);
      ser.end = jenv->GetIntField(seobj, endField);
      ser.document = jenv->GetIntField(seobj, documentField);
      ser.score = jenv->GetDoubleField(seobj, scoreField);
      ser.number = jenv->GetLongField(seobj, numberField);
      ser.ordinal = jenv->GetIntField(seobj, ordField);
      ser.parentOrdinal = jenv->GetIntField(seobj, pOrdField);
      
      arg3->push_back( ser );
    }
  }
  {
    try {
      result = (arg1)->expand(arg2,*arg3);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1RMExpander(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  indri::api::Parameters *arg2 = 0 ;
  indri::api::Parameters p2 ;
  indri::query::RMExpander *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    if( jarg2 != 0 ) {
      jni_parameters_info info;
      java_parameters_init( jenv, info );
      
      java_parameters_map( jenv, info, p2, jarg2 );
    }   
    arg2 = &p2;
  }
  {
    try {
      result = (indri::query::RMExpander *)new indri::query::RMExpander(arg1,*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::query::RMExpander **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_lemurproject_indri_indriJNI_RMExpander_1expand(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jobjectArray jarg3) {
  jstring jresult = 0 ;
  indri::query::RMExpander *arg1 = (indri::query::RMExpander *) 0 ;
  std::string arg2 ;
  std::vector< indri::api::ScoredExtentResult > *arg3 = 0 ;
  std::vector< indri::api::ScoredExtentResult > resin3 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::query::RMExpander **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  } 
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  (&arg2)->assign(arg2_pstr);
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize size = jenv->GetArrayLength(jarg3);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");
    arg3 = &resin3;
    
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg3, i);
      indri::api::ScoredExtentResult ser;
      
      ser.begin = jenv->GetIntField(seobj, beginField);
      ser.end = jenv->GetIntField(seobj, endField);
      ser.document = jenv->GetIntField(seobj, documentField);
      ser.score = jenv->GetDoubleField(seobj, scoreField);
      ser.number = jenv->GetLongField(seobj, numberField);
      ser.ordinal = jenv->GetIntField(seobj, ordField);
      ser.parentOrdinal = jenv->GetIntField(seobj, pOrdField);
      
      arg3->push_back( ser );
    }
  }
  {
    try {
      result = (arg1)->expand(arg2,*arg3);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1RMExpander(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::query::RMExpander *arg1 = (indri::query::RMExpander *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::query::RMExpander **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1PonteExpander(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jlong jresult = 0 ;
  indri::api::QueryEnvironment *arg1 = (indri::api::QueryEnvironment *) 0 ;
  indri::api::Parameters *arg2 = 0 ;
  indri::api::Parameters p2 ;
  indri::query::PonteExpander *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::QueryEnvironment **)&jarg1; 
  {
    if( jarg2 != 0 ) {
      jni_parameters_info info;
      java_parameters_init( jenv, info );
      
      java_parameters_map( jenv, info, p2, jarg2 );
    }   
    arg2 = &p2;
  }
  {
    try {
      result = (indri::query::PonteExpander *)new indri::query::PonteExpander(arg1,*arg2);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::query::PonteExpander **)&jresult = result; 
  return jresult;
}


SWIGEXPORT jstring JNICALL Java_lemurproject_indri_indriJNI_PonteExpander_1expand(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jobjectArray jarg3) {
  jstring jresult = 0 ;
  indri::query::PonteExpander *arg1 = (indri::query::PonteExpander *) 0 ;
  std::string arg2 ;
  std::vector< indri::api::ScoredExtentResult > *arg3 = 0 ;
  std::vector< indri::api::ScoredExtentResult > resin3 ;
  std::string result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::query::PonteExpander **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  } 
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  (&arg2)->assign(arg2_pstr);
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    jsize size = jenv->GetArrayLength(jarg3);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/ScoredExtentResult");
    jfieldID scoreField = jenv->GetFieldID(clazz, "score", "D" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    jfieldID documentField = jenv->GetFieldID(clazz, "document", "I" );
    jfieldID numberField = jenv->GetFieldID(clazz, "number", "J");
    jfieldID ordField = jenv->GetFieldID(clazz, "ordinal", "I");
    jfieldID pOrdField = jenv->GetFieldID(clazz, "parentOrdinal", "I");
    arg3 = &resin3;
    
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg3, i);
      indri::api::ScoredExtentResult ser;
      
      ser.begin = jenv->GetIntField(seobj, beginField);
      ser.end = jenv->GetIntField(seobj, endField);
      ser.document = jenv->GetIntField(seobj, documentField);
      ser.score = jenv->GetDoubleField(seobj, scoreField);
      ser.number = jenv->GetLongField(seobj, numberField);
      ser.ordinal = jenv->GetIntField(seobj, ordField);
      ser.parentOrdinal = jenv->GetIntField(seobj, pOrdField);
      
      arg3->push_back( ser );
    }
  }
  {
    try {
      result = (arg1)->expand(arg2,*arg3);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = jenv->NewStringUTF((&result)->c_str()); 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1PonteExpander(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::query::PonteExpander *arg1 = (indri::query::PonteExpander *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::query::PonteExpander **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1IndexStatus(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::api::IndexStatus *arg1 = (indri::api::IndexStatus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::api::IndexStatus **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexStatus_1status(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2, jstring jarg3, jstring jarg4, jint jarg5, jint jarg6) {
  indri::api::IndexStatus *arg1 = (indri::api::IndexStatus *) 0 ;
  int arg2 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  int arg5 ;
  int arg6 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexStatus **)&jarg1; 
  arg2 = (int)jarg2; 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return ;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
  if (!arg4_pstr) return ;
  std::string arg4_str(arg4_pstr);
  arg4 = &arg4_str;
  jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
  arg5 = (int)jarg5; 
  arg6 = (int)jarg6; 
  {
    try {
      (arg1)->status(arg2,(std::string const &)*arg3,(std::string const &)*arg4,arg5,arg6);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1IndexStatus(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  indri::api::IndexStatus *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    try {
      result = (indri::api::IndexStatus *)new SwigDirector_IndexStatus(jenv);
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::IndexStatus **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexStatus_1director_1connect(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jswig_mem_own, jboolean jweak_global) {
  indri::api::IndexStatus *obj = *((indri::api::IndexStatus **)&objarg);
  (void)jcls;
  SwigDirector_IndexStatus *director = dynamic_cast<SwigDirector_IndexStatus *>(obj);
  if (director) {
    director->swig_connect_director(jenv, jself, jenv->GetObjectClass(jself), (jswig_mem_own == JNI_TRUE), (jweak_global == JNI_TRUE));
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexStatus_1change_1ownership(JNIEnv *jenv, jclass jcls, jobject jself, jlong objarg, jboolean jtake_or_release) {
  indri::api::IndexStatus *obj = *((indri::api::IndexStatus **)&objarg);
  SwigDirector_IndexStatus *director = dynamic_cast<SwigDirector_IndexStatus *>(obj);
  (void)jcls;
  if (director) {
    director->swig_java_change_ownership(jenv, jself, jtake_or_release ? true : false);
  }
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_new_1IndexEnvironment(JNIEnv *jenv, jclass jcls) {
  jlong jresult = 0 ;
  indri::api::IndexEnvironment *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  {
    try {
      result = (indri::api::IndexEnvironment *)new indri::api::IndexEnvironment();
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  *(indri::api::IndexEnvironment **)&jresult = result; 
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_delete_1IndexEnvironment(JNIEnv *jenv, jclass jcls, jlong jarg1) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  
  (void)jenv;
  (void)jcls;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    try {
      delete arg1;
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setDocumentRoot(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->setDocumentRoot((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setAnchorTextPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->setAnchorTextPath((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setOffsetMetadataPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->setOffsetMetadataPath((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setOffsetAnnotationsPath(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->setOffsetAnnotationsPath((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addFileClass_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jstring jarg4, jstring jarg5, jstring jarg6, jstring jarg7, jstring jarg8, jobjectArray jarg9, jobjectArray jarg10, jobjectArray jarg11, jobjectArray jarg12, jobjectArray jarg13) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::string *arg4 = 0 ;
  std::string *arg5 = 0 ;
  std::string *arg6 = 0 ;
  std::string *arg7 = 0 ;
  std::string *arg8 = 0 ;
  std::vector< std::string > *arg9 = 0 ;
  std::vector< std::string > *arg10 = 0 ;
  std::vector< std::string > *arg11 = 0 ;
  std::vector< std::string > *arg12 = 0 ;
  std::map< indri::parse::ConflationPattern *,std::string > *arg13 = 0 ;
  std::vector< std::string > strin9 ;
  std::vector< std::string > strin10 ;
  std::vector< std::string > strin11 ;
  std::vector< std::string > strin12 ;
  std::map< indri::parse::ConflationPattern *,std::string > map13 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return ;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
  if (!arg4_pstr) return ;
  std::string arg4_str(arg4_pstr);
  arg4 = &arg4_str;
  jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
  if(!jarg5) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg5_pstr = (const char *)jenv->GetStringUTFChars(jarg5, 0); 
  if (!arg5_pstr) return ;
  std::string arg5_str(arg5_pstr);
  arg5 = &arg5_str;
  jenv->ReleaseStringUTFChars(jarg5, arg5_pstr); 
  if(!jarg6) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg6_pstr = (const char *)jenv->GetStringUTFChars(jarg6, 0); 
  if (!arg6_pstr) return ;
  std::string arg6_str(arg6_pstr);
  arg6 = &arg6_str;
  jenv->ReleaseStringUTFChars(jarg6, arg6_pstr); 
  if(!jarg7) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg7_pstr = (const char *)jenv->GetStringUTFChars(jarg7, 0); 
  if (!arg7_pstr) return ;
  std::string arg7_str(arg7_pstr);
  arg7 = &arg7_str;
  jenv->ReleaseStringUTFChars(jarg7, arg7_pstr); 
  if(!jarg8) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg8_pstr = (const char *)jenv->GetStringUTFChars(jarg8, 0); 
  if (!arg8_pstr) return ;
  std::string arg8_str(arg8_pstr);
  arg8 = &arg8_str;
  jenv->ReleaseStringUTFChars(jarg8, arg8_pstr); 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg9);
    arg9 = &strin9;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg9, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg9->push_back(stringCopy);
    }
  }
  {
    jsize arrayLength = jenv->GetArrayLength(jarg10);
    arg10 = &strin10;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg10, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg10->push_back(stringCopy);
    }
  }
  {
    jsize arrayLength = jenv->GetArrayLength(jarg11);
    arg11 = &strin11;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg11, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg11->push_back(stringCopy);
    }
  }
  {
    jsize arrayLength = jenv->GetArrayLength(jarg12);
    arg12 = &strin12;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg12, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg12->push_back(stringCopy);
    }
  }
  {
    // make a conflations map13 to go in it
    // get map13 class and entrySet method pointer
    jobject src = jarg13;
    jclass mapClazz = jenv->GetObjectClass(src);
    jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );
    
    // call entry set function to set a Set of entries
    jobject entrySet = jenv->CallObjectMethod(src, mapEntrySet);
    jclass setClazz = jenv->GetObjectClass(entrySet);
    jmethodID setToArray = jenv->GetMethodID(setClazz, "toArray", "()[Ljava/lang/Object;" );
    
    // turn that set into an array of objects (entries)
    jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod(entrySet, setToArray);
    
    // get the array size
    jsize entryArrayLength = jenv->GetArrayLength(entryArray);
    
    jclass conflationClazz = jenv->FindClass("lemurproject/indri/ConflationPattern");
    jfieldID tag_nameField = jenv->GetFieldID(conflationClazz, "tag_name", "Ljava/lang/String;" );
    jfieldID attribute_nameField = jenv->GetFieldID(conflationClazz, "attribute_name", "Ljava/lang/String;"  );
    jfieldID valueField = jenv->GetFieldID(conflationClazz, "value", "Ljava/lang/String;" );
    
    
    for( int i=0; i<entryArrayLength; i++ ) {
      // get the key string
      jobject entryObject = (jstring) jenv->GetObjectArrayElement( entryArray, i );
      jclass mapEntryClazz = jenv->GetObjectClass(entryObject);
      jmethodID mapEntryGetKey = jenv->GetMethodID(mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
      jmethodID mapEntryGetValue = jenv->GetMethodID(mapEntryClazz, "getValue", "()Ljava/lang/Object;" );
      
      jobject key = jenv->CallObjectMethod( entryObject, mapEntryGetKey );
      jobject value = jenv->CallObjectMethod( entryObject, mapEntryGetValue );
      
      indri::parse::ConflationPattern * pattern = new indri::parse::ConflationPattern();
      
      const char* valueChars = jenv->GetStringUTFChars( (jstring) value, 0 );
      std::string valueString = valueChars;
      jenv->ReleaseStringUTFChars( (jstring) value, valueChars );
      
      jstring fieldValue = (jstring) jenv->GetObjectField(key, tag_nameField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->tag_name = valueChars;
      
      fieldValue = (jstring) jenv->GetObjectField(key, attribute_nameField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->attribute_name = valueChars;
      
      fieldValue = (jstring) jenv->GetObjectField(key, valueField);
      valueChars = jenv->GetStringUTFChars( (jstring) fieldValue, 0 );
      if (valueChars[0] == '\0') valueChars = NULL; // empty strings are NULL
      pattern->value = valueChars;
      map13[pattern] = valueString ;
    }
    arg13 = &map13;
  }
  {
    try {
      try {
        (arg1)->addFileClass((std::string const &)*arg2,(std::string const &)*arg3,(std::string const &)*arg4,(std::string const &)*arg5,(std::string const &)*arg6,(std::string const &)*arg7,(std::string const &)*arg8,(std::vector< std::string > const &)*arg9,(std::vector< std::string > const &)*arg10,(std::vector< std::string > const &)*arg11,(std::vector< std::string > const &)*arg12,(std::map< indri::parse::ConflationPattern *,std::string > const &)*arg13);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jobject JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1getFileClassSpec(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  jobject jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  indri::parse::FileClassEnvironmentFactory::Specification *result = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        result = (indri::parse::FileClassEnvironmentFactory::Specification *)(arg1)->getFileClassSpec((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  {
    // look up information about Specification
    jni_specification_info info;
    specification_init(jenv, info);
    //  print_info(info);
    jresult = specification_copy(jenv, info, result); 
    delete(result);
  }
  return jresult;
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addFileClass_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  indri::parse::FileClassEnvironmentFactory::Specification *arg2 = 0 ;
  indri::parse::FileClassEnvironmentFactory::Specification spec2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    // look up information about Specification
    jni_specification_info info;
    specification_init(jenv, info);
    
    jstring tmpString;
    jobjectArray tmpArray;
    jobject tmpMap;
    
    // string name
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.nameField);
    copy_to_string(jenv, tmpString, spec2.name);
    // string tokenizer
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.tokenizerField);
    copy_to_string(jenv, tmpString, spec2.tokenizer);
    // string parser
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.parserField);
    copy_to_string(jenv, tmpString, spec2.parser);
    // string interator
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.iteratorField);
    copy_to_string(jenv, tmpString, spec2.iterator);
    // string startDocTag
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.startDocTagField);
    copy_to_string(jenv, tmpString, spec2.startDocTag);
    // string endDocTag
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.endDocTagField);
    copy_to_string(jenv, tmpString, spec2.endDocTag);
    // string endMetadataTag
    tmpString = (jstring) jenv->GetObjectField(jarg2, info.endMetadataTagField);
    copy_to_string(jenv, tmpString, spec2.endMetadataTag);
    // vector<string> include 
    tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.includeField);
    copy_to_string_vector(jenv, tmpArray, spec2.include);
    // vector<string> exclude
    tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.excludeField);
    copy_to_string_vector(jenv, tmpArray, spec2.exclude);
    // vector<string> index
    tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.indexField);
    copy_to_string_vector(jenv, tmpArray, spec2.index);
    // vector<string> metadata
    tmpArray = (jobjectArray) jenv->GetObjectField(jarg2, info.metadataField);
    copy_to_string_vector(jenv, tmpArray, spec2.metadata);
    // map<string, string> conflations 
    tmpMap = (jobject) jenv->GetObjectField(jarg2, info.conflationsField);
    copy_to_map(jenv, tmpMap, spec2.conflations);
    
    arg2 = &spec2;
  }
  {
    try {
      try {
        (arg1)->addFileClass((indri::parse::FileClassEnvironmentFactory::Specification const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1deleteDocument(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jint jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  int arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  arg2 = (int)jarg2; 
  {
    try {
      try {
        (arg1)->deleteDocument(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setIndexedFields(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > strin2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    arg2 = &strin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg2->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        (arg1)->setIndexedFields((std::vector< std::string > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setNumericField_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3, jstring jarg4) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  std::string *arg4 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = jarg3 ? true : false; 
  if(!jarg4) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg4_pstr = (const char *)jenv->GetStringUTFChars(jarg4, 0); 
  if (!arg4_pstr) return ;
  std::string arg4_str(arg4_pstr);
  arg4 = &arg4_str;
  jenv->ReleaseStringUTFChars(jarg4, arg4_pstr); 
  {
    try {
      try {
        (arg1)->setNumericField((std::string const &)*arg2,arg3,(std::string const &)*arg4);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setNumericField_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = jarg3 ? true : false; 
  {
    try {
      try {
        (arg1)->setNumericField((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setOrdinalField(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = jarg3 ? true : false; 
  {
    try {
      try {
        (arg1)->setOrdinalField((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setParentalField(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jboolean jarg3) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  bool arg3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = jarg3 ? true : false; 
  {
    try {
      try {
        (arg1)->setParentalField((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setMetadataIndexedFields(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2, jobjectArray jarg3) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > *arg3 = 0 ;
  std::vector< std::string > strin2 ;
  std::vector< std::string > strin3 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    arg2 = &strin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg2->push_back(stringCopy);
    }
  }
  {
    jsize arrayLength = jenv->GetArrayLength(jarg3);
    arg3 = &strin3;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg3, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg3->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        (arg1)->setMetadataIndexedFields((std::vector< std::string > const &)*arg2,(std::vector< std::string > const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setStopwords(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobjectArray jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::vector< std::string > *arg2 = 0 ;
  std::vector< std::string > strin2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    jsize arrayLength = jenv->GetArrayLength(jarg2);
    arg2 = &strin2;
    
    for( unsigned int i=0; i<arrayLength; i++ ) {
      jstring str = (jstring) jenv->GetObjectArrayElement(jarg2, i);
      jsize stringLength = jenv->GetStringUTFLength(str);
      const char* stringChars = jenv->GetStringUTFChars(str, 0);
      std::string stringCopy;
      stringCopy.assign( stringChars, stringChars + stringLength );
      arg2->push_back(stringCopy);
    }
  }
  {
    try {
      try {
        (arg1)->setStopwords((std::vector< std::string > const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setStemmer(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->setStemmer((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setMemory(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jlong jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  UINT64 arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  arg2 = (UINT64)jarg2; 
  {
    try {
      try {
        (arg1)->setMemory(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setNormalization(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  {
    try {
      try {
        (arg1)->setNormalization(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1setStoreDocs(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jboolean jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  bool arg2 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  arg2 = jarg2 ? true : false; 
  {
    try {
      try {
        (arg1)->setStoreDocs(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1create_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  indri::api::IndexStatus *arg3 = (indri::api::IndexStatus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = *(indri::api::IndexStatus **)&jarg3; 
  {
    try {
      try {
        (arg1)->create((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1create_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->create((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1open_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jlong jarg3, jobject jarg3_) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  indri::api::IndexStatus *arg3 = (indri::api::IndexStatus *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  (void)jarg3_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  arg3 = *(indri::api::IndexStatus **)&jarg3; 
  {
    try {
      try {
        (arg1)->open((std::string const &)*arg2,arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1open_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->open((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1close(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    try {
      try {
        (arg1)->close();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addFile_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  {
    try {
      try {
        (arg1)->addFile((std::string const &)*arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addFile_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3) {
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return ;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return ;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return ;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    try {
      try {
        (arg1)->addFile((std::string const &)*arg2,(std::string const &)*arg3);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return ;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return ; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return ;
    }
  }
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addString_1_1SWIG_10(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jobjectArray jarg4) {
  jint jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector< indri::parse::MetadataPair > *arg4 = 0 ;
  std::vector< indri::parse::MetadataPair > mdin4 ;
  indri::utility::Buffer mdbuf4 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    // call map.entrySet()
    jclass mapClazz = jenv->GetObjectClass( jarg4 );
    jmethodID mapEntrySetMethod = jenv->GetMethodID( mapClazz, "entrySet", "()Ljava/util/Set;" );
    jobject mapEntrySet = jenv->CallObjectMethod( jarg4, mapEntrySetMethod );
    
    // call entrySet.toArray()
    jclass entrySetClazz = jenv->GetObjectClass( mapEntrySet );
    jmethodID entrySetToArrayMethod = jenv->GetMethodID( entrySetClazz, "toArray", "()[Ljava/lang/Object;" );
    jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod( mapEntrySet, entrySetToArrayMethod );
    
    // get array length
    jsize arrayLength = jenv->GetArrayLength( entryArray );
    arg4 = &mdin4;
    
    jclass stringClazz = jenv->FindClass("java/lang/String");
    unsigned int i;
    
    for( i=0; i<arrayLength; i++ ) {
      jobject mapEntry = jenv->GetObjectArrayElement( entryArray, i );
      jclass mapEntryClazz = jenv->GetObjectClass( mapEntry );
      jmethodID mapEntryGetKeyMethod = jenv->GetMethodID( mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
      jmethodID mapEntryGetValueMethod = jenv->GetMethodID( mapEntryClazz, "getValue", "()Ljava/lang/Object;" );
      
      jobject key = jenv->CallObjectMethod( mapEntry, mapEntryGetKeyMethod );
      jobject value = jenv->CallObjectMethod( mapEntry, mapEntryGetValueMethod );
      
      size_t keyOffset = mdbuf4.position();
      const char* keyChars = jenv->GetStringUTFChars( (jstring) key, 0 );
      jsize keyLength = jenv->GetStringUTFLength( (jstring) key);
      std::string keyString = keyChars;
      char* keyPosition = mdbuf4.write( keyLength+1 );
      strncpy( keyPosition, keyChars, keyLength );
      keyPosition[keyLength] = 0;
      
      size_t valueOffset = mdbuf4.position();
      char* valuePosition = 0;
      jsize valueLength;
      
      if( jenv->IsInstanceOf( value, stringClazz ) ) {
        jstring valueString = (jstring) value;
        const char* valueChars = jenv->GetStringUTFChars( valueString, 0);
        valueLength = jenv->GetStringUTFLength( valueString );
        
        valuePosition = mdbuf4.write( valueLength+1 );
        strncpy( valuePosition, valueChars, valueLength );
        valuePosition[valueLength] = 0;
        valueLength++;
        
        jenv->ReleaseStringUTFChars(valueString, valueChars);
      } else {
        // is byte array
        jbyteArray valueArray = (jbyteArray) value;
        jbyte* valueBytes = jenv->GetByteArrayElements( valueArray, 0 );
        valueLength = jenv->GetArrayLength( valueArray );
        
        valuePosition = mdbuf4.write( valueLength+1 );
        memcpy( valuePosition, valueBytes, valueLength );
        valuePosition[valueLength] = 0;
        
        jenv->ReleaseByteArrayElements(valueArray, valueBytes, 0);
      }
      
      indri::parse::MetadataPair pair;
      pair.key = (char*) keyOffset;
      pair.value = (char*) valueOffset;
      pair.valueLength = valueLength;
      mdin4.push_back(pair);
      
      jenv->ReleaseStringUTFChars( (jstring)key, keyChars);
    }
    
    // now we need to fix up the key and value positions
    for( i=0; i<arrayLength; i++ ) {
      mdin4[i].key = mdbuf4.front() + (size_t) mdin4[i].key;
      mdin4[i].value = mdbuf4.front() + (size_t) mdin4[i].value;
    }
  }
  {
    try {
      try {
        result = (int)(arg1)->addString((std::string const &)*arg2,(std::string const &)*arg3,(std::vector< indri::parse::MetadataPair > const &)*arg4);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addString_1_1SWIG_11(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jstring jarg2, jstring jarg3, jobjectArray jarg4, jobjectArray jarg5) {
  jint jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  std::string *arg2 = 0 ;
  std::string *arg3 = 0 ;
  std::vector< indri::parse::MetadataPair > *arg4 = 0 ;
  std::vector< indri::parse::TagExtent * > *arg5 = 0 ;
  std::vector< indri::parse::MetadataPair > mdin4 ;
  indri::utility::Buffer mdbuf4 ;
  std::vector< indri::parse::TagExtent * > tein5 ;
  indri::utility::Buffer tebuf5 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  if(!jarg2) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg2_pstr = (const char *)jenv->GetStringUTFChars(jarg2, 0); 
  if (!arg2_pstr) return 0;
  std::string arg2_str(arg2_pstr);
  arg2 = &arg2_str;
  jenv->ReleaseStringUTFChars(jarg2, arg2_pstr); 
  if(!jarg3) {
    SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, "null std::string");
    return 0;
  }
  const char *arg3_pstr = (const char *)jenv->GetStringUTFChars(jarg3, 0); 
  if (!arg3_pstr) return 0;
  std::string arg3_str(arg3_pstr);
  arg3 = &arg3_str;
  jenv->ReleaseStringUTFChars(jarg3, arg3_pstr); 
  {
    // call map.entrySet()
    jclass mapClazz = jenv->GetObjectClass( jarg4 );
    jmethodID mapEntrySetMethod = jenv->GetMethodID( mapClazz, "entrySet", "()Ljava/util/Set;" );
    jobject mapEntrySet = jenv->CallObjectMethod( jarg4, mapEntrySetMethod );
    
    // call entrySet.toArray()
    jclass entrySetClazz = jenv->GetObjectClass( mapEntrySet );
    jmethodID entrySetToArrayMethod = jenv->GetMethodID( entrySetClazz, "toArray", "()[Ljava/lang/Object;" );
    jobjectArray entryArray = (jobjectArray) jenv->CallObjectMethod( mapEntrySet, entrySetToArrayMethod );
    
    // get array length
    jsize arrayLength = jenv->GetArrayLength( entryArray );
    arg4 = &mdin4;
    
    jclass stringClazz = jenv->FindClass("java/lang/String");
    unsigned int i;
    
    for( i=0; i<arrayLength; i++ ) {
      jobject mapEntry = jenv->GetObjectArrayElement( entryArray, i );
      jclass mapEntryClazz = jenv->GetObjectClass( mapEntry );
      jmethodID mapEntryGetKeyMethod = jenv->GetMethodID( mapEntryClazz, "getKey", "()Ljava/lang/Object;" );
      jmethodID mapEntryGetValueMethod = jenv->GetMethodID( mapEntryClazz, "getValue", "()Ljava/lang/Object;" );
      
      jobject key = jenv->CallObjectMethod( mapEntry, mapEntryGetKeyMethod );
      jobject value = jenv->CallObjectMethod( mapEntry, mapEntryGetValueMethod );
      
      size_t keyOffset = mdbuf4.position();
      const char* keyChars = jenv->GetStringUTFChars( (jstring) key, 0 );
      jsize keyLength = jenv->GetStringUTFLength( (jstring) key);
      std::string keyString = keyChars;
      char* keyPosition = mdbuf4.write( keyLength+1 );
      strncpy( keyPosition, keyChars, keyLength );
      keyPosition[keyLength] = 0;
      
      size_t valueOffset = mdbuf4.position();
      char* valuePosition = 0;
      jsize valueLength;
      
      if( jenv->IsInstanceOf( value, stringClazz ) ) {
        jstring valueString = (jstring) value;
        const char* valueChars = jenv->GetStringUTFChars( valueString, 0);
        valueLength = jenv->GetStringUTFLength( valueString );
        
        valuePosition = mdbuf4.write( valueLength+1 );
        strncpy( valuePosition, valueChars, valueLength );
        valuePosition[valueLength] = 0;
        valueLength++;
        
        jenv->ReleaseStringUTFChars(valueString, valueChars);
      } else {
        // is byte array
        jbyteArray valueArray = (jbyteArray) value;
        jbyte* valueBytes = jenv->GetByteArrayElements( valueArray, 0 );
        valueLength = jenv->GetArrayLength( valueArray );
        
        valuePosition = mdbuf4.write( valueLength+1 );
        memcpy( valuePosition, valueBytes, valueLength );
        valuePosition[valueLength] = 0;
        
        jenv->ReleaseByteArrayElements(valueArray, valueBytes, 0);
      }
      
      indri::parse::MetadataPair pair;
      pair.key = (char*) keyOffset;
      pair.value = (char*) valueOffset;
      pair.valueLength = valueLength;
      mdin4.push_back(pair);
      
      jenv->ReleaseStringUTFChars( (jstring)key, keyChars);
    }
    
    // now we need to fix up the key and value positions
    for( i=0; i<arrayLength; i++ ) {
      mdin4[i].key = mdbuf4.front() + (size_t) mdin4[i].key;
      mdin4[i].value = mdbuf4.front() + (size_t) mdin4[i].value;
    }
  }
  {
    jsize size = jenv->GetArrayLength(jarg5);
    
    jclass clazz = jenv->FindClass("lemurproject/indri/TagExtent");
    jfieldID nameField = jenv->GetFieldID(clazz, "name", "Ljava/lang/String;" );
    jfieldID beginField = jenv->GetFieldID(clazz, "begin", "I" );
    jfieldID endField = jenv->GetFieldID(clazz, "end", "I" );
    
    arg5 = &tein5;
    
    indri::parse::TagList *tl = new indri::parse::TagList();
    // addTag, endTag
    // tags must be sorted with respect to begin
    for( jsize i=0; i<size; i++ ) {
      jobject seobj  = jenv->GetObjectArrayElement(jarg5, i);
      int tBegin = jenv->GetIntField(seobj, beginField);
      int tEnd = jenv->GetIntField(seobj, endField);
      jstring text = (jstring)jenv->GetObjectField(seobj, nameField);
      const char *textChars = jenv->GetStringUTFChars(text, 0);
      jsize textLength = jenv->GetStringUTFLength(text);
      char* textPosition = tebuf5.write( textLength+1 );
      strncpy( textPosition, textChars, textLength );
      textPosition[textLength] = 0;
      jenv->ReleaseStringUTFChars(text, textChars);
      const char *tName = textPosition;
      tl->addTag(tName, tName, tBegin);
      tl->endTag(tName, tName, tEnd);
    }
    indri::utility::greedy_vector<indri::parse::TagExtent *> tags;
    tl->writeTagList(tags); // sets parents
    tein5.resize(tags.size());
    for (int i = 0; i < tags.size(); i++)
    tein5[i] = tags[i];
    
    /*
      for( jsize i=0; i<size; i++ ) {
        jobject seobj  = jenv->GetObjectArrayElement(jarg5, i);
        indri::parse::TagExtent *te = new indri::parse::TagExtent;
    
        te->begin = jenv->GetIntField(seobj, beginField);
        te->end = jenv->GetIntField(seobj, endField);
        // may leak...
        jstring text = (jstring)jenv->GetObjectField(seobj, nameField);
        const char *textChars = jenv->GetStringUTFChars(text, 0);
        jsize textLength = jenv->GetStringUTFLength(text);
        char* textPosition = tebuf5.write( textLength+1 );
        strncpy( textPosition, textChars, textLength );
        textPosition[textLength] = 0;
        jenv->ReleaseStringUTFChars(text, textChars);
        te->name = textPosition;
    
    // need to pass these in. could use index into input for parent.
        te->number = 0;
        te->parent = 0;
        
        arg5->push_back( te );
      }
    */
  }
  {
    try {
      try {
        result = (int)(arg1)->addString((std::string const &)*arg2,(std::string const &)*arg3,(std::vector< indri::parse::MetadataPair > const &)*arg4,(std::vector< indri::parse::TagExtent * > const &)*arg5);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  {
    for (int i = 0; i < arg5->size(); i++) {
      delete((*arg5)[i]);
    }
  }
  return jresult;
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1addParsedDocument(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_, jobject jarg2) {
  jint jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  indri::api::ParsedDocument *arg2 = (indri::api::ParsedDocument *) 0 ;
  indri::api::ParsedDocument pdoc2 ;
  indri::utility::Buffer buf2 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  
  jni_parseddocument_info info;
  
  parseddocument_init( jenv, info );
  arg2 = &pdoc2;
  
  jstring text = (jstring) jenv->GetObjectField(jarg2, info.textField);
  jobjectArray terms = (jobjectArray) jenv->GetObjectField(jarg2, info.termsField);
  jobjectArray positions = (jobjectArray) jenv->GetObjectField(jarg2, info.positionsField);
  jobjectArray metadata = (jobjectArray) jenv->GetObjectField(jarg2, info.metadataField);
  
  // store text
  const char* textString = jenv->GetStringUTFChars(text, 0);
  jsize textLength = jenv->GetStringUTFLength(text);
  strcpy( buf2.write(textLength+1), textString );
  jenv->ReleaseStringUTFChars(text, textString);
  
  // content is a copy, have to convert it to an offset/length.
  jstring content = (jstring) jenv->GetObjectField(jarg2, info.contentField);
  const char* contentString = jenv->GetStringUTFChars(content, 0);
  jsize contentLength = jenv->GetStringUTFLength(content);
  // find the start offset
  const char *cStart = strstr(textString, contentString);
  // better not be null...
  int contentDelta = cStart ? cStart - textString : 0;
  
  jenv->ReleaseStringUTFChars(content, contentString);
  
  // store terms
  std::vector<int> termPositions;
  jsize termCount = terms ? jenv->GetArrayLength(terms) : 0;
  for( int i=0; i<termCount; i++ ) {
    // get term string
    jstring term = (jstring) jenv->GetObjectArrayElement(terms, i);
    
    if( term != 0 ) {
      termPositions.push_back( buf2.position() );
      const char* termString = jenv->GetStringUTFChars(term, 0);
      jsize termStringLength = jenv->GetStringUTFLength(term);
      strcpy( buf2.write(termStringLength+1), termString );
      jenv->ReleaseStringUTFChars(term, termString);
    } else {
      termPositions.push_back(-1);
    }
  }
  
  // store positions (straight to structure, no buffer necessary)
  jsize positionsCount = positions ? jenv->GetArrayLength(positions) : 0;
  for( int i=0; i<positionsCount; i++ ) {
    jobject position = jenv->GetObjectArrayElement(positions, i);
    indri::parse::TermExtent extent;
    extent.begin = jenv->GetIntField(position, info.beginField);
    extent.end = jenv->GetIntField(position, info.endField);
    pdoc2.positions.push_back(extent);
  }
  
  // store metadata
  jclass mapClazz = jenv->GetObjectClass(metadata);
  jmethodID mapEntrySet = jenv->GetMethodID(mapClazz, "entrySet", "()Ljava/util/Set;" );
  jobject entrySet = jenv->CallObjectMethod(metadata, mapEntrySet);
  jclass entrySetClazz = jenv->GetObjectClass(entrySet);
  jmethodID toArray = jenv->GetMethodID(entrySetClazz, "toArray", "()[Ljava/lang/Object;" );
  jobjectArray metadataArray = (jobjectArray) jenv->CallObjectMethod(entrySet, toArray);
  
  jsize metadataCount = metadata ? jenv->GetArrayLength(metadataArray) : 0;
  std::vector<int> metadataKeyPositions;
  std::vector<int> metadataValuePositions;
  std::vector<int> metadataValueLengths;
  for( int i=0; i<metadataCount; i++ ) {
    jobject md = jenv->GetObjectArrayElement(metadataArray, i);
    jclass entryClazz = jenv->GetObjectClass(md);
    jmethodID mapEntryKey = jenv->GetMethodID(entryClazz, "getKey", "()Ljava/lang/Object;" );
    jmethodID mapEntryValue = jenv->GetMethodID(entryClazz, "getValue", "()Ljava/lang/Object;" );
    
    jstring key = (jstring) jenv->CallObjectMethod(md, mapEntryKey);
    jobject value = jenv->CallObjectMethod(md, mapEntryValue);
    
    metadataValuePositions.push_back( buf2.position() );
    if( jenv->IsInstanceOf(value, info.byteArrayClazz) ) {
      // value is raw bytes
      jbyte* bytes = jenv->GetByteArrayElements( (jbyteArray) value, 0 );
      jsize bytesLength = jenv->GetArrayLength((jbyteArray)value);
      memcpy( buf2.write(bytesLength), bytes, bytesLength );
      jenv->ReleaseByteArrayElements( (jbyteArray)value, bytes, 0 );
      metadataValueLengths.push_back( buf2.position() );
    } else if( jenv->IsInstanceOf(value, info.stringClazz) ) {
      const char* stringChars = jenv->GetStringUTFChars((jstring)value, 0);
      jsize valueStringLength = jenv->GetStringUTFLength((jstring)value);
      metadataValueLengths.push_back(valueStringLength+1);
      strncpy( buf2.write(valueStringLength+1), stringChars, valueStringLength+1 );
      jenv->ReleaseStringUTFChars((jstring)value, stringChars);
    }
    
    metadataKeyPositions.push_back(buf2.position());
    const char* keyChars = jenv->GetStringUTFChars(key, 0);
    int keyLength = jenv->GetStringUTFLength(key);
    strncpy( buf2.write(keyLength+1), keyChars, keyLength+1 );
    jenv->ReleaseStringUTFChars((jstring)key, keyChars);
  }
  
  // now, copy term pointers into arrays
  for( int i=0; i<termPositions.size(); i++ ) {
    pdoc2.terms.push_back( buf2.front() + termPositions[i] );
  }
  
  // copy metadata pointers
  for( int i=0; i<metadataKeyPositions.size(); i++ ) {
    const char* key = buf2.front() + metadataKeyPositions[i];
    const char* value = buf2.front() + metadataValuePositions[i];
    int valueLength = metadataValueLengths[i];
    indri::parse::MetadataPair mPair;
    mPair.key = key;
    mPair.value = value;
    mPair.valueLength = valueLength;
    pdoc2.metadata.push_back(mPair );
  }
  
  // copy text
  pdoc2.text = buf2.front();
  pdoc2.textLength = textLength;
  // content
  pdoc2.content = pdoc2.text + contentDelta;
  pdoc2.contentLength = contentLength;
  
  {
    try {
      try {
        result = (int)(arg1)->addParsedDocument(arg2);
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1documentsIndexed(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    try {
      try {
        result = (int)(arg1)->documentsIndexed();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jint JNICALL Java_lemurproject_indri_indriJNI_IndexEnvironment_1documentsSeen(JNIEnv *jenv, jclass jcls, jlong jarg1, jobject jarg1_) {
  jint jresult = 0 ;
  indri::api::IndexEnvironment *arg1 = (indri::api::IndexEnvironment *) 0 ;
  int result;
  
  (void)jenv;
  (void)jcls;
  (void)jarg1_;
  arg1 = *(indri::api::IndexEnvironment **)&jarg1; 
  {
    try {
      try {
        result = (int)(arg1)->documentsSeen();
      }
      catch(lemur::api::Exception &_e) {
        {
          jclass excep = jenv->FindClass("java/lang/Exception");
          if (excep)
          jenv->ThrowNew(excep, (&_e)->what().c_str());
          return 0;
        }
      }
      
    } catch( lemur::api::Exception& e ) {
      {
        SWIG_JavaException(jenv, SWIG_RuntimeError, e.what().c_str()); return 0; 
      };
      // control does not leave method when thrown. (fixed in 1.3.25
      // return 0;
    }
  }
  jresult = (jint)result; 
  return jresult;
}


SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_RMExpander_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(indri::query::QueryExpander **)&baseptr = *(indri::query::RMExpander **)&jarg1;
    return baseptr;
}

SWIGEXPORT jlong JNICALL Java_lemurproject_indri_indriJNI_PonteExpander_1SWIGUpcast(JNIEnv *jenv, jclass jcls, jlong jarg1) {
    jlong baseptr = 0;
    (void)jenv;
    (void)jcls;
    *(indri::query::QueryExpander **)&baseptr = *(indri::query::PonteExpander **)&jarg1;
    return baseptr;
}

SWIGEXPORT void JNICALL Java_lemurproject_indri_indriJNI_swig_1module_1init(JNIEnv *jenv, jclass jcls) {
  int i;
  
  static struct {
    const char *method;
    const char *signature;
  } methods[1] = {
    {
      "SwigDirector_IndexStatus_status", "(Llemurproject/indri/IndexStatus;ILjava/lang/String;Ljava/lang/String;II)V" 
    }
  };
  Swig::jclass_indriJNI = (jclass) jenv->NewGlobalRef(jcls);
  if (!Swig::jclass_indriJNI) return;
  for (i = 0; i < (int) (sizeof(methods)/sizeof(methods[0])); ++i) {
    Swig::director_methids[i] = jenv->GetStaticMethodID(jcls, methods[i].method, methods[i].signature);
    if (!Swig::director_methids[i]) return;
  }
}


#ifdef __cplusplus
}
#endif

